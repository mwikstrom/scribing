## API Report File for "scribing"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Equatable } from 'paratype';
import { JsonValue } from 'paratype';
import { RecordConstructor } from 'paratype';
import { RecordObject } from 'paratype';
import { Type } from 'paratype';

// @public @sealed
export class DefaultFlowTheme extends DefaultFlowThemeBase {
    constructor();
    static readonly classType: Type<RecordObject<    {}, "default"> & Equatable & Readonly<{}> & DefaultFlowTheme>;
    getParagraphTheme(variant: ParagraphStyleVariant): ParagraphTheme;
    static get instance(): DefaultFlowTheme;
}

// @public
export const DefaultFlowThemeBase: RecordConstructor<    {}, FlowTheme, "default">;

// @public @sealed
export class FlowBatch extends FlowBatchBase implements Readonly<FlowBatchProps> {
    constructor(props?: FlowBatchProps);
    afterInsertion(other: FlowRange): FlowOperation | null;
    afterRemoval(other: FlowRange): FlowOperation | null;
    applyToContent(content: FlowContent, theme?: FlowTheme): FlowContent;
    // @override
    applyToSelection(selection: FlowSelection, mine: boolean): FlowSelection | null;
    static readonly classType: Type<FlowBatch>;
    static fromArray(operations: FlowOperation[]): FlowOperation | null;
    static fromData(data: FlowBatchData): FlowBatch;
    invert(content: FlowContent): FlowOperation | null;
    transform(other: FlowOperation): FlowOperation | null;
}

// @public
export const FlowBatchBase: RecordConstructor<FlowBatchProps, FlowOperation, FlowBatchData>;

// @public
export type FlowBatchData = readonly FlowOperation[];

// @public
export interface FlowBatchProps {
    operations: readonly FlowOperation[];
}

// @public @sealed
export class FlowContent extends FlowContentBase implements Readonly<FlowContentProps> {
    constructor(props?: FlowContentProps);
    append(...nodes: readonly FlowNode[]): FlowContent;
    append(theme: FlowTheme | undefined, ...nodes: readonly FlowNode[]): FlowContent;
    static readonly classType: Type<FlowContent>;
    copy(range: FlowRange): FlowContent;
    formatParagraph(range: FlowRange, style: ParagraphStyle, theme?: FlowTheme): FlowContent;
    formatText(range: FlowRange, style: TextStyle, theme?: FlowTheme): FlowContent;
    static fromData(data: FlowContentData): FlowContent;
    static fromJsonValue(value: JsonValue): FlowContent;
    insert(position: number, ...nodes: readonly FlowNode[]): FlowContent;
    insert(position: number, theme: FlowTheme | undefined, ...nodes: readonly FlowNode[]): FlowContent;
    peek(position?: number): FlowCursor;
    remove(range: FlowRange): FlowContent;
    get size(): number;
    toJsonValue(): JsonValue;
    unformatParagraph(range: FlowRange, style: ParagraphStyle): FlowContent;
    unformatText(range: FlowRange, style: TextStyle): FlowContent;
}

// @public
export const FlowContentBase: RecordConstructor<FlowContentProps, Object, FlowContentData>;

// @public
export type FlowContentData = readonly FlowNode[];

// @public
export interface FlowContentProps {
    nodes: readonly FlowNode[];
}

// @public
export class FlowCursor {
    // @internal
    constructor(content: FlowContent);
    // @internal
    constructor(content: FlowContent, symbol: symbol, index: number, offset: number, position: number);
    get after(): Iterable<FlowNode>;
    get before(): Iterable<FlowNode>;
    getParagraphStyle(): ParagraphStyle | null;
    getTextStyle(): TextStyle | null;
    get index(): number;
    move(distance: number): FlowCursor;
    moveToStartOfNextNode(): FlowCursor | null;
    moveToStartOfNode(): FlowCursor;
    moveToStartOfPreviousNode(): FlowCursor | null;
    get node(): FlowNode | null;
    get offset(): number;
    get position(): number;
    range(distance: number): Iterable<FlowNode>;
}

// @public @sealed
export class FlowEditorState extends FlowEditorStateBase {
    applyMine(operation: FlowOperation): FlowEditorState;
    applyTheirs(operation: FlowOperation): FlowEditorState;
    static get empty(): FlowEditorState;
    getUniformParagraphStyle(diff?: Set<keyof ParagraphStyleProps>): ParagraphStyle;
    getUniformTextStyle(diff?: Set<keyof TextStyleProps>): TextStyle;
}

// @public
export const FlowEditorStateBase: RecordConstructor<    {
content: FlowContent;
selection: FlowSelection | null;
theme: FlowTheme;
caret: RecordObject<Partial<{
bold: any;
italic: any;
underline: any;
strike: any;
baseline: any;
}>, Partial<{
bold: any;
italic: any;
underline: any;
strike: any;
baseline: any;
}>> & Equatable & Readonly<Partial<{
bold: any;
italic: any;
underline: any;
strike: any;
baseline: any;
}>> & TextStyle;
}, Object, {
content: FlowContent;
selection: FlowSelection | null;
theme: FlowTheme;
caret: RecordObject<Partial<{
bold: any;
italic: any;
underline: any;
strike: any;
baseline: any;
}>, Partial<{
bold: any;
italic: any;
underline: any;
strike: any;
baseline: any;
}>> & Equatable & Readonly<Partial<{
bold: any;
italic: any;
underline: any;
strike: any;
baseline: any;
}>> & TextStyle;
}>;

// @public
export interface FlowEditorStateProps {
    // (undocumented)
    caret: TextStyle;
    // (undocumented)
    content: FlowContent;
    // (undocumented)
    selection: FlowSelection | null;
    // (undocumented)
    theme: FlowTheme;
}

// @public
export abstract class FlowNode {
    static readonly baseType: Type<FlowNode>;
    abstract formatParagraph(style: ParagraphStyle): FlowNode;
    abstract formatText(style: TextStyle): FlowNode;
    static fromJsonValue(value: JsonValue): FlowNode;
    abstract getUniformParagraphStyle(theme?: ParagraphTheme, diff?: Set<keyof ParagraphStyleProps>): ParagraphStyle | null;
    abstract getUniformTextStyle(theme?: ParagraphTheme, diff?: Set<keyof TextStyleProps>): TextStyle | null;
    abstract readonly size: number;
    abstract toData(): unknown;
    toJsonValue(): JsonValue;
    abstract unformatAmbient(theme: ParagraphTheme): FlowNode;
    abstract unformatParagraph(style: ParagraphStyle): FlowNode;
    abstract unformatText(style: TextStyle): FlowNode;
}

// @public
export abstract class FlowOperation {
    // @internal
    abstract afterInsertion(other: FlowRange): FlowOperation | null;
    // @internal
    abstract afterRemoval(other: FlowRange): FlowOperation | null;
    abstract applyToContent(content: FlowContent, theme?: FlowTheme): FlowContent;
    abstract applyToSelection(selection: FlowSelection, mine: boolean): FlowSelection | null;
    static readonly baseType: Type<FlowOperation>;
    static fromJsonValue(value: JsonValue): FlowOperation;
    abstract invert(content: FlowContent): FlowOperation | null;
    abstract toData(): unknown;
    toJsonValue(): JsonValue;
    abstract transform(other: FlowOperation): FlowOperation | null;
}

// @public @sealed
export class FlowRange extends FlowRangeBase implements Readonly<FlowRangeProps> {
    static at(position: number, distance?: number): FlowRange;
    static readonly classType: Type<FlowRange>;
    contains(position: number): boolean;
    deflate(delta: number): FlowRange;
    get distance(): number;
    get first(): number;
    static fromData(data: FlowRangeTuple): FlowRange;
    inflate(delta: number): FlowRange;
    intersect(other: FlowRange): FlowRange;
    get isBackward(): boolean;
    get isCollapsed(): boolean;
    get last(): number;
    reverse(): FlowRange;
    set(key: "first" | "last" | keyof FlowRangeProps, value: number): this;
    get size(): number;
    toString(): string;
    translate(delta: number): FlowRange;
}

// @public
export const FlowRangeBase: RecordConstructor<FlowRangeProps, Object, FlowRangeTuple>;

// @public
export interface FlowRangeProps {
    anchor: number;
    focus: number;
}

// @public @sealed
export class FlowRangeSelection extends FlowRangeSelectionBase implements Readonly<FlowRangeSelectionProps> {
    // @override
    afterInsertion(range: FlowRange, mine: boolean): FlowSelection | null;
    // @override
    afterRemoval(range: FlowRange, mine: boolean): FlowSelection | null;
    static readonly classType: Type<RecordObject<FlowRangeSelectionProps, FlowRangeSelectionProps> & Equatable & Readonly<FlowRangeSelectionProps> & FlowRangeSelection>;
    // @override
    formatParagraph(style: ParagraphStyle): FlowOperation | null;
    // @override
    formatText(style: TextStyle): FlowOperation | null;
    // @override
    getUniformParagraphStyle(content: FlowContent, theme?: FlowTheme, diff?: Set<keyof ParagraphStyleProps>): ParagraphStyle;
    // @override
    getUniformTextStyle(content: FlowContent, theme?: FlowTheme, diff?: Set<keyof TextStyleProps>): TextStyle;
    // @override
    insert(content: FlowContent): FlowOperation | null;
    // @override
    get isCollapsed(): boolean;
    // @override
    remove(options?: RemoveFlowSelectionOptions): FlowOperation | null;
    // @override
    unformatParagraph(style: ParagraphStyle): FlowOperation | null;
    // @override
    unformatText(style: TextStyle): FlowOperation | null;
}

// @public
export const FlowRangeSelectionBase: RecordConstructor<FlowRangeSelectionProps, FlowSelection, FlowRangeSelectionProps>;

// @public
export interface FlowRangeSelectionProps {
    range: FlowRange;
}

// @public
export type FlowRangeTuple = [number, number];

// @public
export abstract class FlowSelection {
    // @internal
    abstract afterInsertion(range: FlowRange, mine: boolean): FlowSelection | null;
    // @internal
    abstract afterRemoval(range: FlowRange, mine: boolean): FlowSelection | null;
    static readonly baseType: Type<FlowSelection>;
    abstract formatParagraph(style: ParagraphStyle): FlowOperation | null;
    abstract formatText(style: TextStyle): FlowOperation | null;
    static fromJsonValue(value: JsonValue): FlowSelection;
    abstract getUniformParagraphStyle(content: FlowContent, theme?: FlowTheme, diff?: Set<keyof ParagraphStyleProps>): ParagraphStyle;
    abstract getUniformTextStyle(content: FlowContent, theme?: FlowTheme, diff?: Set<keyof TextStyleProps>): TextStyle;
    abstract insert(content: FlowContent): FlowOperation | null;
    abstract get isCollapsed(): boolean;
    abstract remove(options?: RemoveFlowSelectionOptions): FlowOperation | null;
    toJsonValue(): JsonValue;
    abstract unformatParagraph(style: ParagraphStyle): FlowOperation | null;
    abstract unformatText(style: TextStyle): FlowOperation | null;
}

// @public
export abstract class FlowTheme {
    static readonly baseType: Type<FlowTheme>;
    static fromJsonValue(value: JsonValue): FlowTheme;
    abstract getParagraphTheme(variant: ParagraphStyleVariant): ParagraphTheme;
    toJsonValue(): JsonValue;
}

// @public @sealed
export class FormatParagraph extends FormatParagraphBase implements Readonly<FormatParagraphProps> {
    afterInsertion(other: FlowRange): FlowOperation | null;
    afterRemoval(other: FlowRange): FlowOperation | null;
    // @override
    applyToContent(content: FlowContent): FlowContent;
    // @override
    applyToSelection(selection: FlowSelection): FlowSelection;
    static readonly classType: Type<FormatParagraph>;
    static fromData(data: FormatParagraphData): FormatParagraph;
    // @override
    invert(content: FlowContent): FlowOperation | null;
    // @override
    transform(other: FlowOperation): FlowOperation | null;
}

// @public
export const FormatParagraphBase: RecordConstructor<FormatParagraphProps, FlowOperation, FormatParagraphData>;

// @public
export interface FormatParagraphData extends FormatParagraphProps {
    format: "para";
}

// @public
export interface FormatParagraphProps {
    range: FlowRange;
    style: ParagraphStyle;
}

// @public @sealed
export class FormatText extends FormatTextBase implements Readonly<FormatTextProps> {
    afterInsertion(other: FlowRange): FlowOperation | null;
    afterRemoval(other: FlowRange): FlowOperation | null;
    // @override
    applyToContent(content: FlowContent): FlowContent;
    // @override
    applyToSelection(selection: FlowSelection): FlowSelection;
    static readonly classType: Type<FormatText>;
    static fromData(data: FormatTextData): FormatText;
    // @override
    invert(content: FlowContent): FlowOperation | null;
    // @override
    transform(other: FlowOperation): FlowOperation | null;
}

// @public
export const FormatTextBase: RecordConstructor<FormatTextProps, FlowOperation, FormatTextData>;

// @public
export interface FormatTextData extends FormatTextProps {
    format: "text";
}

// @public
export interface FormatTextProps {
    range: FlowRange;
    style: TextStyle;
}

// @public
export abstract class InlineNode extends FlowNode {
    formatParagraph(): this;
    formatText(style: TextStyle): this;
    // @override
    getUniformParagraphStyle(theme?: ParagraphTheme): ParagraphStyle | null;
    // @override
    getUniformTextStyle(theme?: ParagraphTheme): TextStyle;
    abstract set(key: "style", value: TextStyle): this;
    abstract readonly style: TextStyle;
    unformatAmbient(theme: ParagraphTheme): this;
    unformatParagraph(): this;
    unformatText(style: TextStyle): this;
}

// @public @sealed
export class InsertContent extends InsertContentBase implements InsertContentProps {
    afterInsertion(other: FlowRange): FlowOperation | null;
    afterRemoval(other: FlowRange): FlowOperation | null;
    applyToContent(content: FlowContent, theme?: FlowTheme): FlowContent;
    // @override
    applyToSelection(selection: FlowSelection, mine: boolean): FlowSelection | null;
    static readonly classType: Type<InsertContent>;
    static fromData(data: InsertContentData): InsertContent;
    invert(): FlowOperation | null;
    toData(): InsertContentData;
    transform(other: FlowOperation): FlowOperation | null;
    // @internal
    translate(delta: number): InsertContent;
}

// @public
export const InsertContentBase: RecordConstructor<InsertContentProps, FlowOperation, InsertContentData>;

// @public
export interface InsertContentData {
    at: number;
    insert: FlowContent;
}

// @public
export interface InsertContentProps {
    content: FlowContent;
    position: number;
}

// @public @sealed
export class LineBreak extends LineBreakBase implements LineBreakProps {
    constructor(props?: LineBreakProps);
    static readonly classType: Type<LineBreak>;
    static fromData(data: LineBreakData): LineBreak;
    readonly size = 1;
}

// @public
export const LineBreakBase: RecordConstructor<LineBreakProps, InlineNode, LineBreakData>;

// @public
export interface LineBreakData {
    break: "line";
    style?: TextStyle;
}

// @public
export interface LineBreakProps {
    style: TextStyle;
}

// @public
export const PARAGRAPH_STYLE_VARIANTS: readonly ["normal", "h1", "h2", "h3", "h4", "h5", "h6", "title", "subtitle", "preamble", "code"];

// @public @sealed
export class ParagraphBreak extends ParagraphBreakBase implements ParagraphBreakProps {
    constructor(props?: ParagraphBreakProps);
    static readonly classType: Type<ParagraphBreak>;
    formatParagraph(style: ParagraphStyle): this;
    formatText(): this;
    static fromData(data: ParagraphBreakData): ParagraphBreak;
    // @override
    getUniformParagraphStyle(theme?: ParagraphTheme): ParagraphStyle | null;
    // @override
    getUniformTextStyle(theme?: ParagraphTheme): TextStyle;
    readonly size = 1;
    unformatAmbient(theme: ParagraphTheme): this;
    unformatParagraph(style: ParagraphStyle): this;
    unformatText(): this;
}

// @public
export const ParagraphBreakBase: RecordConstructor<ParagraphBreakProps, FlowNode, ParagraphBreakData>;

// @public
export interface ParagraphBreakData {
    break: "para";
    style?: ParagraphStyle;
}

// @public
export interface ParagraphBreakProps {
    style: ParagraphStyle;
}

// @public @sealed
export class ParagraphStyle extends ParagraphStyleBase implements Readonly<ParagraphStyleProps> {
    constructor(props?: ParagraphStyleProps);
    static readonly classType: Type<RecordObject<Partial<{
    alignment: "start" | "center" | "end" | "justify";
    direction: "ltr" | "rtl";
    variant: "normal" | "h1" | "h2" | "h3" | "h4" | "h5" | "h6" | "title" | "subtitle" | "preamble" | "code";
    lineSpacing: number;
    }>, Partial<{
    alignment: "start" | "center" | "end" | "justify";
    direction: "ltr" | "rtl";
    variant: "normal" | "h1" | "h2" | "h3" | "h4" | "h5" | "h6" | "title" | "subtitle" | "preamble" | "code";
    lineSpacing: number;
    }>> & Equatable & Readonly<Partial<{
        alignment: "start" | "center" | "end" | "justify";
        direction: "ltr" | "rtl";
        variant: "normal" | "h1" | "h2" | "h3" | "h4" | "h5" | "h6" | "title" | "subtitle" | "preamble" | "code";
        lineSpacing: number;
    }>> & ParagraphStyle>;
    static get empty(): ParagraphStyle;
    get isEmpty(): boolean;
}

// @public
export const ParagraphStyleBase: RecordConstructor<Partial<{
alignment: "start" | "center" | "end" | "justify";
direction: "ltr" | "rtl";
variant: "normal" | "h1" | "h2" | "h3" | "h4" | "h5" | "h6" | "title" | "subtitle" | "preamble" | "code";
lineSpacing: number;
}>, Object, Partial<{
alignment: "start" | "center" | "end" | "justify";
direction: "ltr" | "rtl";
variant: "normal" | "h1" | "h2" | "h3" | "h4" | "h5" | "h6" | "title" | "subtitle" | "preamble" | "code";
lineSpacing: number;
}>>;

// @public
export interface ParagraphStyleProps {
    alignment?: "start" | "center" | "end" | "justify";
    direction?: "ltr" | "rtl";
    lineSpacing?: number;
    variant?: ParagraphStyleVariant;
}

// @public
export type ParagraphStyleVariant = (typeof PARAGRAPH_STYLE_VARIANTS)[number];

// @public
export const ParagraphStyleVariantType: Type<ParagraphStyleVariant>;

// @public
export abstract class ParagraphTheme {
    abstract getAmbientParagraphStyle(): ParagraphStyle;
    abstract getAmbientTextStyle(): TextStyle;
}

// @public
export interface RemoveFlowSelectionOptions {
    content?: FlowContent;
    whenCollapsed?: "removeBackward" | "removeForward" | "noop";
}

// @public @sealed
export class RemoveRange extends RemoveRangeBase implements Readonly<RemoveRangeProps> {
    afterInsertion(other: FlowRange): FlowOperation | null;
    afterRemoval(other: FlowRange): FlowOperation | null;
    // @override
    applyToContent(content: FlowContent): FlowContent;
    // @override
    applyToSelection(selection: FlowSelection, mine: boolean): FlowSelection | null;
    static readonly classType: Type<RemoveRange>;
    static fromData(data: RemoveRangeData): RemoveRange;
    // @override
    invert(content: FlowContent): InsertContent;
    // @override
    transform(other: FlowOperation): FlowOperation | null;
}

// @public
export const RemoveRangeBase: RecordConstructor<RemoveRangeProps, FlowOperation, RemoveRangeData>;

// @public
export interface RemoveRangeData {
    remove: FlowRange;
}

// @public
export interface RemoveRangeProps {
    range: FlowRange;
}

// @public @sealed
export class TextRun extends TextRunBase implements Readonly<TextRunProps> {
    constructor(props?: TextRunProps);
    after(position: number): TextRun;
    append(value: string): TextRun;
    before(position: number): TextRun;
    static readonly classType: Type<TextRun>;
    static fromData(data: TextRunData): TextRun;
    // @internal
    static merge(first: TextRun, second: TextRun): TextRun;
    static normalizeText(value: unknown): string;
    // @internal
    static shouldMerge(first: TextRun, second: TextRun): boolean;
    readonly size: number;
    split(position: number): [TextRun, TextRun];
}

// @public
export const TextRunBase: RecordConstructor<TextRunProps, InlineNode, TextRunData>;

// @public
export type TextRunData = string | (Pick<TextRunProps, "text"> & Partial<Omit<TextRunProps, "text">>);

// @public
export interface TextRunProps {
    style: TextStyle;
    text: string;
}

// @public @sealed
export class TextStyle extends TextStyleBase implements Readonly<TextStyleProps> {
    constructor(props?: TextStyleProps);
    static readonly classType: Type<RecordObject<Partial<{
    bold: boolean;
    italic: boolean;
    underline: boolean;
    strike: boolean;
    baseline: "normal" | "sub" | "super";
    }>, Partial<{
    bold: boolean;
    italic: boolean;
    underline: boolean;
    strike: boolean;
    baseline: "normal" | "sub" | "super";
    }>> & Equatable & Readonly<Partial<{
    bold: boolean;
    italic: boolean;
    underline: boolean;
    strike: boolean;
    baseline: "normal" | "sub" | "super";
    }>> & TextStyle>;
    static get empty(): TextStyle;
    get isEmpty(): boolean;
}

// @public
export const TextStyleBase: RecordConstructor<Partial<{
bold: boolean;
italic: boolean;
underline: boolean;
strike: boolean;
baseline: "normal" | "sub" | "super";
}>, Object, Partial<{
bold: boolean;
italic: boolean;
underline: boolean;
strike: boolean;
baseline: "normal" | "sub" | "super";
}>>;

// @public
export interface TextStyleProps {
    baseline?: "normal" | "sub" | "super";
    bold?: boolean;
    italic?: boolean;
    strike?: boolean;
    underline?: boolean;
}

// @public @sealed
export class UnformatParagraph extends UnformatParagraphBase implements Readonly<UnformatParagraphProps> {
    afterInsertion(other: FlowRange): FlowOperation | null;
    afterRemoval(other: FlowRange): FlowOperation | null;
    // @override
    applyToContent(content: FlowContent): FlowContent;
    // @override
    applyToSelection(selection: FlowSelection): FlowSelection;
    static readonly classType: Type<UnformatParagraph>;
    static fromData(data: UnformatParagraphData): UnformatParagraph;
    // @override
    invert(content: FlowContent): FlowOperation | null;
    // @override
    transform(other: FlowOperation): FlowOperation | null;
}

// @public
export const UnformatParagraphBase: RecordConstructor<UnformatParagraphProps, FlowOperation, UnformatParagraphData>;

// @public
export interface UnformatParagraphData extends UnformatParagraphProps {
    unformat: "para";
}

// @public
export interface UnformatParagraphProps {
    range: FlowRange;
    style: ParagraphStyle;
}

// @public @sealed
export class UnformatText extends UnformatTextBase implements Readonly<UnformatTextProps> {
    afterInsertion(other: FlowRange): FlowOperation | null;
    afterRemoval(other: FlowRange): FlowOperation | null;
    // @override
    applyToContent(content: FlowContent): FlowContent;
    // @override
    applyToSelection(selection: FlowSelection): FlowSelection;
    static readonly classType: Type<UnformatText>;
    static fromData(data: UnformatTextData): UnformatText;
    // @override
    invert(content: FlowContent): FlowOperation | null;
    // @override
    transform(other: FlowOperation): FlowOperation | null;
}

// @public
export const UnformatTextBase: RecordConstructor<UnformatTextProps, FlowOperation, UnformatTextData>;

// @public
export interface UnformatTextData extends UnformatTextProps {
    unformat: "text";
}

// @public
export interface UnformatTextProps {
    range: FlowRange;
    style: TextStyle;
}

```
