## API Report File for "scribing"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Equatable } from 'paratype';
import { ErrorCallback } from 'paratype';
import { JsonValue } from 'paratype';
import { PathArray } from 'paratype';
import { RecordConstructor } from 'paratype';
import { RecordObject } from 'paratype';
import { RecordType } from 'paratype';
import { Type } from 'paratype';

// @public
export const BASELINE_OFFSETS: readonly ["normal", "sub", "super"];

// @public
export type BaselineOffset = (typeof BASELINE_OFFSETS)[number];

// @public (undocumented)
export type BasicFetch = (url: string, init?: BasicRequestInit) => Promise<Response>;

// @public (undocumented)
export interface BasicRequestInit {
    // (undocumented)
    body: string;
    // (undocumented)
    headers?: Record<string, string>;
    // (undocumented)
    method?: string;
}

// @public
export const BOX_VARIANTS: readonly ["basic", "contained", "outlined", "alert", "quote"];

// @public @sealed
export class BoxStyle extends BoxStyleBase implements Readonly<BoxStyleProps> {
    constructor(props?: BoxStyleProps);
    static get ambient(): BoxStyle;
    static readonly classType: Type<RecordObject<Partial<{
    variant: "basic" | "contained" | "outlined" | "alert" | "quote";
    color: "default" | "subtle" | "primary" | "secondary" | "information" | "success" | "warning" | "error";
    inline: boolean;
    source: string | null;
    interaction: Interaction | null;
    }>, Partial<{
    variant: "basic" | "contained" | "outlined" | "alert" | "quote";
    color: "default" | "subtle" | "primary" | "secondary" | "information" | "success" | "warning" | "error";
    inline: boolean;
    source: string | null;
    interaction: Interaction | null;
    }>> & Equatable & Readonly<Partial<{
        variant: "basic" | "contained" | "outlined" | "alert" | "quote";
        color: "default" | "subtle" | "primary" | "secondary" | "information" | "success" | "warning" | "error";
        inline: boolean;
        source: string | null;
        interaction: Interaction | null;
    }>> & BoxStyle>;
    static get empty(): BoxStyle;
    get isEmpty(): boolean;
}

// @public
export const BoxStyleBase: RecordConstructor<Partial<{
variant: "basic" | "contained" | "outlined" | "alert" | "quote";
color: "default" | "subtle" | "primary" | "secondary" | "information" | "success" | "warning" | "error";
inline: boolean;
source: string | null;
interaction: Interaction | null;
}>, Object, Partial<{
variant: "basic" | "contained" | "outlined" | "alert" | "quote";
color: "default" | "subtle" | "primary" | "secondary" | "information" | "success" | "warning" | "error";
inline: boolean;
source: string | null;
interaction: Interaction | null;
}>>;

// @public
export interface BoxStyleProps {
    color?: FlowColor;
    inline?: boolean;
    interaction?: Interaction | null;
    source?: string | null;
    variant?: BoxVariant;
}

// @public
export type BoxVariant = (typeof BOX_VARIANTS)[number];

// @public
export const BoxVariantType: Type<BoxVariant>;

// @public @sealed
export class CellPosition extends CellPositionBase implements Readonly<CellPositionProps> {
    static at(row: number, column: number): CellPosition;
    static readonly classType: Type<CellPosition>;
    compare(other: CellPositionProps): -1 | 0 | 1;
    equals(other: CellPositionProps): boolean;
    static fromData(data: CellPositionData): CellPosition;
    next(columnCount?: number, rowCount?: number): CellPosition | null;
    // (undocumented)
    static parse(input: string, throwOnError?: boolean): CellPosition | null;
    // (undocumented)
    static parse(input: string, throwOnError: true): CellPosition;
    // (undocumented)
    static parseColumnIndex(input: string, throwOnError?: boolean): number | null;
    // (undocumented)
    static parseColumnIndex(input: string, throwOnError: true): number;
    // (undocumented)
    static parseRowIndex(input: string, throwOnError?: boolean): number | null;
    // (undocumented)
    static parseRowIndex(input: string, throwOnError: true): number;
    // (undocumented)
    static stringifyColumnIndex(input: number, throwOnError?: boolean): string | null;
    // (undocumented)
    static stringifyColumnIndex(input: number, throwOnError: true): string;
    // (undocumented)
    static stringifyRowIndex(input: number, throwOnError?: boolean): string | null;
    // (undocumented)
    static stringifyRowIndex(input: number, throwOnError: true): string;
    toString(): string;
    valueOf(): string;
}

// @public
export const CellPositionBase: RecordConstructor<CellPositionProps, Object, string>;

// @public
export type CellPositionData = string;

// @public
export interface CellPositionProps {
    column: number;
    row: number;
}

// @public @sealed
export class CellRange extends CellRangeBase implements Readonly<CellRangeProps> {
    // (undocumented)
    afterInsertColumn(index: number, count: number): CellRange;
    // (undocumented)
    afterInsertRow(index: number, count: number): CellRange;
    // (undocumented)
    afterRemoveColumn(index: number, count: number): CellRange | null;
    // (undocumented)
    afterRemoveRow(index: number, count: number): CellRange | null;
    static at(anchor: CellPosition, focus?: CellPosition): CellRange;
    static readonly classType: Type<CellRange>;
    // (undocumented)
    get columnRange(): FlowRange;
    // (undocumented)
    contains(cell: CellPosition): boolean;
    equals(other: CellRangeProps): boolean;
    // (undocumented)
    get firstColumnIndex(): number;
    // (undocumented)
    get firstRowIndex(): number;
    static fromData(data: CellRangeData): CellRange;
    // (undocumented)
    get isSingleCell(): boolean;
    // (undocumented)
    get lastColumnIndex(): number;
    // (undocumented)
    get lastRowIndex(): number;
    // (undocumented)
    static parse(input: string, throwOnError?: boolean): CellRange | null;
    // (undocumented)
    static parse(input: string, throwOnError: true): CellRange;
    // (undocumented)
    get rowRange(): FlowRange;
    // (undocumented)
    setAxisRange(axis: "column" | "row", value: FlowRange): CellRange;
    // (undocumented)
    setAxisRange(axis: "column" | "row", value: FlowRange | null): CellRange | null;
    toString(): string;
    valueOf(): string;
}

// @public
export const CellRangeBase: RecordConstructor<CellRangeProps, Object, string>;

// @public
export type CellRangeData = string;

// @public
export interface CellRangeProps {
    anchor: CellPosition;
    focus: CellPosition;
}

// @public @sealed
export class CompleteUpload extends CompleteUploadBase implements CompleteUploadProps {
    afterInsertFlow(): this;
    afterRemoveFlow(): this;
    // @override
    applyToContent(content: FlowContent): FlowContent;
    // @override
    applyToSelection(selection: FlowSelection): FlowSelection;
    static readonly classType: Type<CompleteUpload>;
    static fromData(data: CompleteUploadData): CompleteUpload;
    // @override
    invert(): null;
    mergeNext(): null;
    // @override
    transform(other: FlowOperation): FlowOperation | null;
}

// @public
export const CompleteUploadBase: RecordConstructor<CompleteUploadProps, FlowOperation, CompleteUploadData>;

// @public
export interface CompleteUploadData {
    complete_upload: string;
    url: string;
}

// @public
export interface CompleteUploadProps {
    id: string;
    url: string;
}

// @public @sealed
export class DefaultFlowTheme extends DefaultFlowThemeBase {
    constructor();
    static readonly classType: Type<RecordObject<    {}, "default"> & Equatable & Readonly<{}> & DefaultFlowTheme>;
    getBoxTheme(style: BoxStyle): FlowTheme;
    getParagraphTheme(variant: ParagraphVariant): ParagraphTheme;
    static get instance(): DefaultFlowTheme;
}

// @public
export const DefaultFlowThemeBase: RecordConstructor<    {}, FlowTheme, "default">;

// @public @sealed
export class DynamicText extends DynamicTextBase implements DynamicTextProps {
    static readonly classType: Type<DynamicText>;
    static fromData(data: DynamicTextData): DynamicText;
    readonly size = 1;
}

// @public
export const DynamicTextBase: RecordConstructor<DynamicTextProps, InlineNode, DynamicTextData>;

// @public
export interface DynamicTextData {
    dynamic: string;
    style?: TextStyle;
}

// @public
export interface DynamicTextProps {
    expression: string;
    style: TextStyle;
}

// @public @sealed
export class EditBox extends EditBoxBase implements EditBoxProps {
    static readonly classType: Type<EditBox>;
    createReplacementNode(content: FlowContent, before: FlowNode): FlowNode;
    static fromData(data: EditBoxData): EditBox;
    getInnerContentFromNode(node: FlowNode): FlowContent;
    getInnerThemeFromNode(node: FlowNode, outer?: FlowTheme): FlowTheme;
    mergeNext(next: FlowOperation): FlowOperation | null;
}

// @public
export const EditBoxBase: RecordConstructor<EditBoxProps, NestedFlowOperation, EditBoxData>;

// @public
export interface EditBoxData {
    at: number;
    edit: "box";
    op: FlowOperation;
}

// @public
export interface EditBoxProps {
    inner: FlowOperation;
    position: number;
}

// @public @sealed
export class EditTableCell extends EditTableCellBase implements EditTableCellProps {
    static readonly classType: Type<EditTableCell>;
    createReplacementNode(content: FlowContent, before: FlowNode): FlowNode;
    static fromData(data: EditTableCellData): EditTableCell;
    getInnerContentFromNode(node: FlowNode): FlowContent;
    getInnerThemeFromNode(node: FlowNode, outer?: FlowTheme): FlowTheme;
    mergeNext(next: FlowOperation): FlowOperation | null;
}

// @public
export const EditTableCellBase: RecordConstructor<EditTableCellProps, NestedFlowOperation, EditTableCellData>;

// @public
export interface EditTableCellData {
    cell: CellPosition;
    edit: "cell";
    op: FlowOperation;
    table: number;
}

// @public
export interface EditTableCellProps {
    cell: CellPosition;
    inner: FlowOperation;
    position: number;
}

// @public @sealed
export class EndMarkup extends EndMarkupBase implements EndMarkupProps {
    constructor(props: EndMarkupProps);
    static readonly classType: Type<EndMarkup>;
    static fromData(data: EndMarkupData): EndMarkup;
    readonly size = 1;
}

// @public
export const EndMarkupBase: RecordConstructor<EndMarkupProps, InlineNode, EndMarkupData>;

// @public
export interface EndMarkupData {
    // (undocumented)
    end_markup: string;
    // (undocumented)
    style?: TextStyle;
}

// @public
export interface EndMarkupProps {
    // (undocumented)
    style: TextStyle;
    // (undocumented)
    tag: string;
}

// @public
export const filterNotNull: <T>(array: readonly T[]) => Exclude<T, null | undefined>[];

// @public
export const FLOW_COLORS: readonly ["default", "subtle", "primary", "secondary", "information", "success", "warning", "error"];

// @public @sealed
export class FlowBatch extends FlowBatchBase implements Readonly<FlowBatchProps> {
    constructor(props?: FlowBatchProps);
    afterInsertFlow(other: FlowRange): FlowOperation | null;
    afterRemoveFlow(other: FlowRange): FlowOperation | null;
    applyToContent(content: FlowContent, theme?: FlowTheme): FlowContent;
    // @override
    applyToSelection(selection: FlowSelection, mine: boolean): FlowSelection | null;
    static readonly classType: Type<FlowBatch>;
    static fromArray(operations: FlowOperation[]): FlowOperation | null;
    static fromData(data: FlowBatchData): FlowBatch;
    invert(content: FlowContent): FlowOperation | null;
    mergeNext(next: FlowOperation): FlowOperation | null;
    transform(other: FlowOperation): FlowOperation | null;
}

// @public
export const FlowBatchBase: RecordConstructor<FlowBatchProps, FlowOperation, FlowBatchData>;

// @public
export type FlowBatchData = readonly FlowOperation[];

// @public
export interface FlowBatchProps {
    operations: readonly FlowOperation[];
}

// @public @sealed
export class FlowBox extends FlowBoxBase {
    static readonly classType: Type<FlowBox>;
    completeUpload(id: string, url: string): FlowNode;
    formatBox(style: BoxStyle): this;
    formatParagraph(): this;
    formatText(): this;
    static fromData(data: FlowBoxData): FlowBox;
    // @override
    getUniformParagraphStyle(): ParagraphStyle | null;
    // @override
    getUniformTextStyle(): TextStyle | null;
    readonly size = 1;
    unformatAmbient(): this;
    unformatBox(style: BoxStyle): this;
    unformatParagraph(): this;
    unformatText(): this;
}

// @public
export const FlowBoxBase: RecordConstructor<FlowBoxProps, FlowNode, FlowBoxData>;

// @public
export interface FlowBoxData {
    // (undocumented)
    box: FlowContent;
    // (undocumented)
    style?: BoxStyle;
}

// @public
export interface FlowBoxProps {
    // (undocumented)
    content: FlowContent;
    // (undocumented)
    style: BoxStyle;
}

// @public @sealed
export class FlowBoxSelection extends FlowBoxSelectionBase {
    static readonly classType: Type<FlowBoxSelection>;
    static fromData(data: FlowBoxSelectionData): FlowBoxSelection;
    // @override
    protected getInnerContentFromNode(node: FlowNode): FlowContent;
    // @override
    protected getInnerSelection(): FlowSelection;
    // @override
    protected getInnerThemeFromNode(node: FlowNode, outer?: FlowTheme): FlowTheme;
    // @override
    protected getOuterOperation(inner: FlowOperation): FlowOperation;
    // @override
    protected setInnerSelection(value: FlowSelection): NestedFlowSelection;
}

// @public
export const FlowBoxSelectionBase: RecordConstructor<FlowBoxSelectionProps, NestedFlowSelection, FlowBoxSelectionData>;

// @public
export interface FlowBoxSelectionData {
    // (undocumented)
    box: number;
    // (undocumented)
    content: FlowSelection;
}

// @public
export interface FlowBoxSelectionProps {
    // (undocumented)
    content: FlowSelection;
    // (undocumented)
    position: number;
}

// @public
export type FlowColor = (typeof FLOW_COLORS)[number];

// @public
export const FlowColorType: Type<FlowColor>;

// @public @sealed
export class FlowContent extends FlowContentBase implements Readonly<FlowContentProps> {
    constructor(props?: FlowContentProps);
    append(...nodes: readonly FlowNode[]): FlowContent;
    append(theme: FlowTheme | undefined, ...nodes: readonly FlowNode[]): FlowContent;
    static readonly classType: Type<FlowContent>;
    completeUpload(id: string, url: string): FlowContent;
    copy(range: FlowRange): FlowContent;
    digest(hashFunc?: SubtleCrypto["digest"]): Promise<string>;
    static get empty(): FlowContent;
    static get emptyParagraph(): FlowContent;
    formatBox(range: FlowRange, style: BoxStyle, theme?: FlowTheme): FlowContent;
    formatParagraph(range: FlowRange, style: ParagraphStyle, theme?: FlowTheme): FlowContent;
    formatText(range: FlowRange, style: TextStyle, theme?: FlowTheme): FlowContent;
    static fromData(data: FlowContentData): FlowContent;
    static fromJsonValue(value: JsonValue): FlowContent;
    incrementListLevel(range: FlowRange, delta: number, theme?: FlowTheme): FlowContent;
    insert(position: number, ...nodes: readonly FlowNode[]): FlowContent;
    insert(position: number, theme: FlowTheme | undefined, ...nodes: readonly FlowNode[]): FlowContent;
    static readonly jsonMimeType = "application/vnd.scribing-flow+json";
    peek(position?: number): FlowCursor;
    remove(range: FlowRange): FlowContent;
    replace(remove: FlowRange, ...insert: FlowNode[]): FlowContent;
    get size(): number;
    toJsonValue(): JsonValue;
    unformatAmbient(theme: FlowTheme): FlowContent;
    unformatBox(range: FlowRange, style: BoxStyle): FlowContent;
    unformatParagraph(range: FlowRange, style: ParagraphStyle): FlowContent;
    unformatText(range: FlowRange, style: TextStyle): FlowContent;
}

// @public
export const FlowContentBase: RecordConstructor<FlowContentProps, Object, FlowContentData>;

// @public
export type FlowContentData = readonly FlowNode[];

// @public
export interface FlowContentProps {
    nodes: readonly FlowNode[];
}

// @public
export class FlowCursor {
    // @internal
    constructor(content: FlowContent);
    // @internal
    constructor(content: FlowContent, symbol: symbol, index: number, offset: number, position: number);
    get after(): Iterable<FlowNode>;
    get before(): Iterable<FlowNode>;
    findNodeForward(predicate: (node: FlowNode) => boolean): FlowCursor | null;
    getParagraphStyle(): ParagraphStyle | null;
    getTextStyle(): TextStyle | null;
    get index(): number;
    move(distance: number): FlowCursor;
    moveToStartOfNextNode(): FlowCursor | null;
    moveToStartOfNode(): FlowCursor;
    moveToStartOfPreviousNode(): FlowCursor | null;
    get node(): FlowNode | null;
    get offset(): number;
    get position(): number;
    range(distance: number): Iterable<FlowNode>;
}

// @public @sealed
export class FlowIcon extends FlowIconBase implements FlowIconProps {
    static readonly classType: Type<FlowIcon>;
    static fromData(data: FlowIconData): FlowIcon;
    readonly size = 1;
}

// @public
export const FlowIconBase: RecordConstructor<FlowIconProps, InlineNode, FlowIconData>;

// @public
export interface FlowIconData {
    icon: string;
    style?: TextStyle;
}

// @public
export interface FlowIconProps {
    data: string;
    style: TextStyle;
}

// @public @sealed
export class FlowImage extends FlowImageBase implements FlowImageProps {
    static readonly classType: Type<FlowImage>;
    // @override
    completeUpload(id: string, url: string): FlowNode;
    static fromData(data: FlowImageData): FlowImage;
    readonly size = 1;
}

// @public
export const FlowImageBase: RecordConstructor<FlowImageProps, InlineNode, FlowImageData>;

// @public
export interface FlowImageData {
    image: ImageSource;
    style?: TextStyle;
}

// @public
export interface FlowImageProps {
    source: ImageSource;
    style: TextStyle;
}

// @public
export abstract class FlowNode {
    static readonly baseType: Type<FlowNode>;
    abstract completeUpload(id: string, url: string): FlowNode;
    abstract formatBox(style: BoxStyle, theme?: FlowTheme): FlowNode;
    abstract formatParagraph(style: ParagraphStyle, theme?: FlowTheme): FlowNode;
    abstract formatText(style: TextStyle, theme?: FlowTheme): FlowNode;
    static fromJsonValue(value: JsonValue): FlowNode;
    abstract getUniformParagraphStyle(theme?: ParagraphTheme, diff?: Set<keyof ParagraphStyleProps>): ParagraphStyle | null;
    abstract getUniformTextStyle(theme?: ParagraphTheme, diff?: Set<keyof TextStyleProps>): TextStyle | null;
    abstract readonly size: number;
    abstract toData(): unknown;
    toJsonValue(): JsonValue;
    abstract unformatAmbient(theme: ParagraphTheme): FlowNode;
    abstract unformatBox(style: BoxStyle): FlowNode;
    abstract unformatParagraph(style: ParagraphStyle): FlowNode;
    abstract unformatText(style: TextStyle): FlowNode;
}

// @public
export abstract class FlowOperation {
    // @internal
    abstract afterInsertFlow(other: FlowRange): FlowOperation | null;
    // @internal
    abstract afterRemoveFlow(other: FlowRange): FlowOperation | null;
    abstract applyToContent(content: FlowContent, theme?: FlowTheme): FlowContent;
    abstract applyToSelection(selection: FlowSelection, mine: boolean): FlowSelection | null;
    static readonly baseType: Type<FlowOperation>;
    static fromJsonValue(value: JsonValue): FlowOperation;
    abstract invert(content: FlowContent): FlowOperation | null;
    abstract mergeNext(next: FlowOperation): FlowOperation | null;
    abstract toData(): unknown;
    toJsonValue(): JsonValue;
    abstract transform(other: FlowOperation): FlowOperation | null;
}

// @public (undocumented)
export interface FlowPresence {
    // (undocumented)
    client: string;
    // (undocumented)
    seen: Date;
    // (undocumented)
    selection: FlowSelection | null;
    // (undocumented)
    user: string;
}

// @public (undocumented)
export const FlowPresenceType: RecordType<FlowPresence>;

// @public @sealed
export class FlowRange extends FlowRangeBase implements Readonly<FlowRangeProps> {
    static at(position: number, distance?: number): FlowRange;
    static readonly classType: Type<FlowRange>;
    contains(position: number): boolean;
    deflate(delta: number): FlowRange;
    get distance(): number;
    get first(): number;
    static fromData(data: FlowRangeTuple): FlowRange;
    inflate(delta: number): FlowRange;
    intersect(other: FlowRange): FlowRange;
    get isBackward(): boolean;
    get isCollapsed(): boolean;
    get last(): number;
    reverse(): FlowRange;
    set(key: "first" | "last" | keyof FlowRangeProps, value: number): this;
    get size(): number;
    toString(): string;
    translate(delta: number): FlowRange;
}

// @public
export const FlowRangeBase: RecordConstructor<FlowRangeProps, Object, FlowRangeTuple>;

// @public
export interface FlowRangeProps {
    anchor: number;
    focus: number;
}

// @public @sealed
export class FlowRangeSelection extends FlowRangeSelectionBase implements Readonly<FlowRangeSelectionProps> {
    // @override
    afterInsertFlow(range: FlowRange, mine: boolean): FlowSelection | null;
    // @override
    afterRemoveFlow(range: FlowRange, mine: boolean): FlowSelection | null;
    static readonly classType: Type<RecordObject<FlowRangeSelectionProps, FlowRangeSelectionProps> & Equatable & Readonly<FlowRangeSelectionProps> & FlowRangeSelection>;
    // @override
    formatBox(style: BoxStyle): FlowOperation | null;
    // @override
    formatList(content: FlowContent, kind: "ordered" | "unordered" | null): FlowOperation | null;
    // @override
    formatParagraph(style: ParagraphStyle, options?: TargetOptions): FlowOperation | null;
    // @override
    formatTable(): FlowOperation | null;
    // @override
    formatTableColumn(): FlowOperation | null;
    // @override
    formatText(style: TextStyle): FlowOperation | null;
    // @override
    getUniformBoxStyle(content: FlowContent, theme?: FlowTheme, diff?: Set<keyof BoxStyleProps>): BoxStyle;
    // @override
    getUniformParagraphStyle(content: FlowContent, theme?: FlowTheme, diff?: Set<keyof ParagraphStyleProps>): ParagraphStyle;
    // @override
    getUniformTextStyle(content: FlowContent, theme?: FlowTheme, diff?: Set<keyof TextStyleProps>): TextStyle;
    // @override
    incrementListLevel(content: FlowContent, delta?: number): FlowOperation | null;
    // @override
    insert(content: FlowContent, options?: TargetOptions): FlowOperation | null;
    // @override
    insertTableColumnAfter(): FlowOperation | null;
    // @override
    insertTableColumnBefore(): FlowOperation | null;
    // @override
    insertTableRowAfter(): FlowOperation | null;
    // @override
    insertTableRowBefore(): FlowOperation | null;
    // @override
    get isCollapsed(): boolean;
    // @override
    mergeTableCell(): FlowOperation | null;
    // @override
    remove(options?: RemoveFlowSelectionOptions): FlowOperation | null;
    // @override
    removeTableColumn(): FlowOperation | null;
    // @override
    removeTableRow(): FlowOperation | null;
    // @override
    setDynamicTextExpression(content: FlowContent, expression: string): FlowOperation | null;
    // @override
    setIcon(content: FlowContent, data: string): FlowOperation | null;
    // @override
    setImageSource(content: FlowContent, source: ImageSource): FlowOperation | null;
    // @override
    splitTableCell(): FlowOperation | null;
    // @override
    transformRanges(transform: (range: FlowRange, options?: TargetOptions) => FlowRange | null, options?: TargetOptions): FlowSelection | null;
    // @override
    unformatBox(style: BoxStyle): FlowOperation | null;
    // @override
    unformatParagraph(style: ParagraphStyle): FlowOperation | null;
    // @override
    unformatTable(): FlowOperation | null;
    // @override
    unformatTableColumn(): FlowOperation | null;
    // @override
    unformatText(style: TextStyle): FlowOperation | null;
    // @override
    visitRanges(callback: (range: FlowRange | CellRange, options: VisitRangeOptions) => void, options?: Partial<VisitRangeOptions>): void;
}

// @public
export const FlowRangeSelectionBase: RecordConstructor<FlowRangeSelectionProps, FlowSelection, FlowRangeSelectionProps>;

// @public
export interface FlowRangeSelectionProps {
    range: FlowRange;
}

// @public
export type FlowRangeTuple = [number, number];

// @public
export abstract class FlowSelection {
    // @internal
    abstract afterInsertFlow(range: FlowRange, mine: boolean): FlowSelection | null;
    // @internal
    abstract afterRemoveFlow(range: FlowRange, mine: boolean): FlowSelection | null;
    static readonly baseType: Type<FlowSelection>;
    decrementListLevel(content: FlowContent, delta?: number): FlowOperation | null;
    abstract formatBox(style: BoxStyle, options?: TargetOptions): FlowOperation | null;
    abstract formatList(content: FlowContent, kind: "ordered" | "unordered" | null): FlowOperation | null;
    abstract formatParagraph(style: ParagraphStyle, options?: TargetOptions): FlowOperation | null;
    abstract formatTable(style: TableStyle, options?: TargetOptions): FlowOperation | null;
    abstract formatTableColumn(style: TableColumnStyle, options?: TargetOptions): FlowOperation | null;
    abstract formatText(style: TextStyle, options?: TargetOptions): FlowOperation | null;
    static fromJsonValue(value: JsonValue): FlowSelection;
    abstract getUniformBoxStyle(content: FlowContent, theme?: FlowTheme, diff?: Set<keyof BoxStyleProps>): BoxStyle;
    abstract getUniformParagraphStyle(content: FlowContent, theme?: FlowTheme, diff?: Set<keyof ParagraphStyleProps>): ParagraphStyle;
    abstract getUniformTextStyle(content: FlowContent, theme?: FlowTheme, diff?: Set<keyof TextStyleProps>): TextStyle;
    abstract incrementListLevel(content: FlowContent, delta?: number): FlowOperation | null;
    abstract insert(content: FlowContent, options?: TargetOptions): FlowOperation | null;
    abstract insertTableColumnAfter(content: FlowContent, count?: number): FlowOperation | null;
    abstract insertTableColumnBefore(content: FlowContent, count?: number): FlowOperation | null;
    abstract insertTableRowAfter(content: FlowContent, count?: number): FlowOperation | null;
    abstract insertTableRowBefore(content: FlowContent, count?: number): FlowOperation | null;
    abstract get isCollapsed(): boolean;
    abstract mergeTableCell(content: FlowContent): FlowOperation | null;
    abstract remove(options?: RemoveFlowSelectionOptions): FlowOperation | null;
    abstract removeTableColumn(content: FlowContent): FlowOperation | null;
    abstract removeTableRow(content: FlowContent): FlowOperation | null;
    // @internal (undocumented)
    static readonly rootReplace: VisitRangeOptions["replace"];
    // @internal (undocumented)
    static readonly rootWrap: VisitRangeOptions["wrap"];
    abstract setDynamicTextExpression(content: FlowContent, expression: string): FlowOperation | null;
    abstract setIcon(content: FlowContent, data: string): FlowOperation | null;
    abstract setImageSource(content: FlowContent, source: ImageSource): FlowOperation | null;
    abstract splitTableCell(content: FlowContent): FlowOperation | null;
    toJsonValue(): JsonValue;
    abstract transformRanges(transform: (range: FlowRange, options?: TargetOptions) => FlowRange | null, options?: TargetOptions): FlowSelection | null;
    abstract unformatBox(style: BoxStyle, options?: TargetOptions): FlowOperation | null;
    abstract unformatParagraph(style: ParagraphStyle, options?: TargetOptions): FlowOperation | null;
    abstract unformatTable(style: TableStyle, options?: TargetOptions): FlowOperation | null;
    abstract unformatTableColumn(style: TableColumnStyle, options?: TargetOptions): FlowOperation | null;
    abstract unformatText(style: TextStyle, options?: TargetOptions): FlowOperation | null;
    abstract visitRanges(callback: (range: FlowRange | CellRange, options: VisitRangeOptions) => void, options?: Partial<VisitRangeOptions>): void;
}

// @public (undocumented)
export interface FlowSyncInput {
    // (undocumented)
    client: string;
    // (undocumented)
    operation: FlowOperation | null;
    // (undocumented)
    selection: FlowSelection | null;
    // (undocumented)
    version: number;
}

// @public (undocumented)
export const FlowSyncInputType: RecordType<FlowSyncInput>;

// @public (undocumented)
export interface FlowSyncOutput {
    // (undocumented)
    digest: string;
    // (undocumented)
    merge: FlowOperation | null;
    // (undocumented)
    presence: FlowPresence[];
    // (undocumented)
    version: number;
}

// @public (undocumented)
export const FlowSyncOutputType: RecordType<FlowSyncOutput>;

// @public (undocumented)
export interface FlowSyncProtocol {
    // (undocumented)
    read(): Promise<FlowSyncSnapshot | null>;
    // (undocumented)
    sync(input: FlowSyncInput): Promise<FlowSyncOutput | null>;
}

// @public (undocumented)
export interface FlowSyncSnapshot {
    // (undocumented)
    content: FlowContent;
    // (undocumented)
    digest: string;
    // (undocumented)
    presence: FlowPresence[];
    // (undocumented)
    theme: FlowTheme;
    // (undocumented)
    version: number;
}

// @public (undocumented)
export const FlowSyncSnapshotType: RecordType<FlowSyncSnapshot>;

// @public @sealed
export class FlowTable extends FlowTableBase {
    static readonly classType: Type<FlowTable>;
    completeUpload(id: string, url: string): FlowNode;
    formatBox(): this;
    // (undocumented)
    formatColumn(index: number, style: TableColumnStyle): FlowTable;
    formatParagraph(): this;
    formatText(): this;
    static fromData(data: FlowTableData): FlowTable;
    // @internal (undocumented)
    getCellTheme(position: CellPosition, outer?: FlowTheme): FlowTheme;
    // @override
    getUniformParagraphStyle(): ParagraphStyle | null;
    // @override
    getUniformTextStyle(): TextStyle | null;
    // (undocumented)
    insertColumn(index: number, count?: number): FlowTable;
    // (undocumented)
    insertRow(index: number, count?: number): FlowTable;
    // (undocumented)
    removeColumn(index: number, count?: number): FlowTable;
    // (undocumented)
    removeRow(index: number, count?: number): FlowTable;
    readonly size = 1;
    unformatAmbient(): this;
    unformatBox(): this;
    // (undocumented)
    unformatColumn(index: number, style: TableColumnStyle): FlowTable;
    unformatParagraph(): this;
    unformatText(): this;
}

// @public
export const FlowTableBase: RecordConstructor<FlowTableProps, FlowNode, FlowTableData>;

// @public @sealed
export class FlowTableCell extends FlowTableCellBase {
    static readonly classType: Type<FlowTableCell>;
    static get empty(): FlowTableCell;
    static get emptyParagraph(): FlowTableCell;
    static fromData(data: FlowTableCellData): FlowTableCell;
    // (undocumented)
    getSpannedPositions(root: CellPosition, includeSelf?: boolean): CellPosition[];
}

// @public
export const FlowTableCellBase: RecordConstructor<FlowTableCellProps, Object, FlowTableCellData>;

// @public
export type FlowTableCellData = FlowContent | {
    content: FlowContent;
    colSpan?: number;
    rowSpan?: number;
};

// @public
export interface FlowTableCellProps {
    // (undocumented)
    colSpan: number;
    // (undocumented)
    content: FlowContent;
    // (undocumented)
    rowSpan: number;
}

// @public @sealed
export class FlowTableCellSelection extends FlowTableCellSelectionBase {
    static readonly classType: Type<FlowTableCellSelection>;
    static fromData(data: FlowTableCellSelectionData): FlowTableCellSelection;
    // @override
    protected getInnerContentFromNode(node: FlowNode): FlowContent;
    // @override
    protected getInnerSelection(): FlowSelection;
    // @override
    protected getInnerThemeFromNode(node: FlowNode, outer?: FlowTheme): FlowTheme;
    // @override
    protected getOuterOperation(inner: FlowOperation): FlowOperation;
    // @override
    protected setInnerSelection(value: FlowSelection): NestedFlowSelection;
}

// @public
export const FlowTableCellSelectionBase: RecordConstructor<FlowTableCellSelectionProps, NestedFlowSelection, FlowTableCellSelectionData>;

// @public
export interface FlowTableCellSelectionData {
    // (undocumented)
    cell: CellPosition;
    // (undocumented)
    content: FlowSelection;
    // (undocumented)
    table: number;
}

// @public
export interface FlowTableCellSelectionProps {
    // (undocumented)
    cell: CellPosition;
    // (undocumented)
    content: FlowSelection;
    // (undocumented)
    position: number;
}

// @public @sealed (undocumented)
export class FlowTableContent {
    // Warning: (ae-forgotten-export) The symbol "FlowTableContentOptions" needs to be exported by the entry point index.d.ts
    constructor(cells?: Iterable<[string, FlowTableCell]>, options?: FlowTableContentOptions);
    // (undocumented)
    static readonly classType: Type<FlowTableContent>;
    // (undocumented)
    get columnCount(): number;
    // (undocumented)
    get defaultCellContent(): FlowContent;
    // (undocumented)
    static fromJsonValue(value: JsonValue, error?: ErrorCallback, path?: PathArray): FlowTableContent;
    // (undocumented)
    getCell(position: CellPosition, throwOnError?: boolean): FlowTableCell | null;
    // (undocumented)
    getCell(position: CellPosition, throwOnError: true): FlowTableCell;
    // (undocumented)
    insertColumn(index: number, count?: number): FlowTableContent;
    // (undocumented)
    insertRow(index: number, count?: number): FlowTableContent;
    // (undocumented)
    map<T>(callback: (cell: FlowTableCell, position: CellPosition) => T): T[];
    // (undocumented)
    merge(position: CellPosition, colSpan: number, rowSpan: number): FlowTableContent;
    // (undocumented)
    get positions(): readonly CellPosition[];
    // (undocumented)
    removeColumn(index: number, count?: number): FlowTableContent;
    // (undocumented)
    removeRow(index: number, count?: number): FlowTableContent;
    // (undocumented)
    get rowCount(): number;
    // (undocumented)
    setContent(position: CellPosition, content: FlowContent): FlowTableContent;
    // (undocumented)
    split(position: CellPosition): FlowTableContent;
    // (undocumented)
    toJsonValue(error?: ErrorCallback, path?: PathArray): JsonValue;
    // (undocumented)
    updateAllContent(callback: (content: FlowContent, position: CellPosition) => FlowContent): FlowTableContent;
}

// @public
export interface FlowTableData {
    // (undocumented)
    columns?: Map<string, TableColumnStyle>;
    // (undocumented)
    style?: TableStyle;
    // (undocumented)
    table: FlowTableContent;
}

// @public
export interface FlowTableProps {
    // (undocumented)
    columns: Map<string, TableColumnStyle>;
    // (undocumented)
    content: FlowTableContent;
    // (undocumented)
    style: TableStyle;
}

// @public @sealed
export class FlowTableSelection extends FlowTableSelectionBase {
    // @internal
    readonly __is_table_selection__ = true;
    // @override
    afterInsertFlow(range: FlowRange): FlowSelection | null;
    // @override
    afterRemoveFlow(range: FlowRange, mine: boolean): FlowSelection | null;
    static readonly classType: Type<FlowTableSelection>;
    // @override
    formatBox(style: BoxStyle, options?: TargetOptions): FlowOperation | null;
    // @override
    formatList(content: FlowContent, kind: "ordered" | "unordered" | null): FlowOperation | null;
    // @override
    formatParagraph(style: ParagraphStyle, options?: TargetOptions): FlowOperation | null;
    // @override
    formatTable(style: TableStyle): FlowOperation | null;
    // @override
    formatTableColumn(style: TableColumnStyle): FlowOperation | null;
    // @override
    formatText(style: TextStyle, options?: TargetOptions): FlowOperation | null;
    static fromData(data: FlowTableSelectionData): FlowTableSelection;
    // @override
    getUniformBoxStyle(content: FlowContent, theme?: FlowTheme, diff?: Set<keyof BoxStyleProps>): BoxStyle;
    // @override
    getUniformParagraphStyle(content: FlowContent, theme?: FlowTheme, diff?: Set<keyof ParagraphStyleProps>): ParagraphStyle;
    // @override
    getUniformTextStyle(content: FlowContent, theme?: FlowTheme, diff?: Set<keyof TextStyleProps>): TextStyle;
    // @override
    incrementListLevel(content: FlowContent, delta?: number): FlowOperation | null;
    // @override
    insert(): FlowOperation | null;
    // @override
    insertTableColumnAfter(content: FlowContent, count?: number): FlowOperation | null;
    // @override
    insertTableColumnBefore(_: FlowContent, count?: number): FlowOperation | null;
    // @override
    insertTableRowAfter(content: FlowContent, count?: number): FlowOperation | null;
    // @override
    insertTableRowBefore(content: FlowContent, count?: number): FlowOperation | null;
    // @override
    get isCollapsed(): boolean;
    // @override
    mergeTableCell(content: FlowContent): FlowOperation | null;
    // @override
    remove(options?: RemoveFlowSelectionOptions): FlowOperation | null;
    // @override
    removeTableColumn(): FlowOperation | null;
    // @override
    removeTableRow(): FlowOperation | null;
    // @override
    setDynamicTextExpression(content: FlowContent, expression: string): FlowOperation | null;
    // @override
    setIcon(content: FlowContent, data: string): FlowOperation | null;
    // @override
    setImageSource(content: FlowContent, source: ImageSource): FlowOperation | null;
    // @override
    splitTableCell(): FlowOperation | null;
    // @override
    transformRanges(transform: (range: FlowRange, options?: TargetOptions) => FlowRange | null, options?: TargetOptions): FlowSelection | null;
    // @override
    unformatBox(style: BoxStyle, options?: TargetOptions): FlowOperation | null;
    // @override
    unformatParagraph(style: ParagraphStyle, options?: TargetOptions): FlowOperation | null;
    // @override
    unformatTable(style: TableStyle): FlowOperation | null;
    // @override
    unformatTableColumn(style: TableColumnStyle): FlowOperation | null;
    // @override
    unformatText(style: TextStyle, options?: TargetOptions): FlowOperation | null;
    // @override
    visitRanges(callback: (range: FlowRange | CellRange, options: VisitRangeOptions) => void, options?: Partial<VisitRangeOptions>): void;
}

// @public
export const FlowTableSelectionBase: RecordConstructor<FlowTableSelectionProps, FlowSelection, FlowTableSelectionData>;

// @public
export interface FlowTableSelectionData {
    // (undocumented)
    range: CellRange;
    // (undocumented)
    table: number;
}

// @public
export interface FlowTableSelectionProps {
    // (undocumented)
    position: number;
    // (undocumented)
    range: CellRange;
}

// @public
export abstract class FlowTheme {
    static readonly baseType: Type<FlowTheme>;
    static fromJsonValue(value: JsonValue): FlowTheme;
    abstract getBoxTheme(style: BoxStyle): FlowTheme;
    abstract getParagraphTheme(variant: ParagraphVariant): ParagraphTheme;
    toJsonValue(): JsonValue;
}

// @public
export const FONT_FAMILIES: readonly ["body", "heading", "monospace"];

// @public
export type FontFamily = (typeof FONT_FAMILIES)[number];

// @public @sealed
export class FormatBox extends FormatBoxBase implements Readonly<FormatBoxProps> {
    afterInsertFlow(other: FlowRange): FlowOperation | null;
    afterRemoveFlow(other: FlowRange): FlowOperation | null;
    // @override
    applyToContent(content: FlowContent, theme?: FlowTheme): FlowContent;
    // @override
    applyToSelection(selection: FlowSelection): FlowSelection;
    static readonly classType: Type<FormatBox>;
    static fromData(data: FormatBoxData): FormatBox;
    // @override
    invert(content: FlowContent): FlowOperation | null;
    mergeNext(next: FlowOperation): FlowOperation | null;
    // @override
    transform(other: FlowOperation): FlowOperation | null;
}

// @public
export const FormatBoxBase: RecordConstructor<FormatBoxProps, FlowOperation, FormatBoxData>;

// @public
export interface FormatBoxData extends FormatBoxProps {
    format: "box";
}

// @public
export interface FormatBoxProps {
    range: FlowRange;
    style: BoxStyle;
}

// @public @sealed
export class FormatParagraph extends FormatParagraphBase implements Readonly<FormatParagraphProps> {
    afterInsertFlow(other: FlowRange): FlowOperation | null;
    afterRemoveFlow(other: FlowRange): FlowOperation | null;
    // @override
    applyToContent(content: FlowContent, theme?: FlowTheme): FlowContent;
    // @override
    applyToSelection(selection: FlowSelection): FlowSelection;
    static readonly classType: Type<FormatParagraph>;
    static fromData(data: FormatParagraphData): FormatParagraph;
    // @override
    invert(content: FlowContent): FlowOperation | null;
    mergeNext(next: FlowOperation): FlowOperation | null;
    // @override
    transform(other: FlowOperation): FlowOperation | null;
}

// @public
export const FormatParagraphBase: RecordConstructor<FormatParagraphProps, FlowOperation, FormatParagraphData>;

// @public
export interface FormatParagraphData extends FormatParagraphProps {
    format: "para";
}

// @public
export interface FormatParagraphProps {
    range: FlowRange;
    style: ParagraphStyle;
}

// @public @sealed
export class FormatTable extends FormatTableBase implements FormatTableProps {
    // (undocumented)
    afterInsertColumn(): TableOperation | null;
    // (undocumented)
    afterInsertRow(): TableOperation | null;
    // (undocumented)
    afterRemoveColumn(): TableOperation | null;
    // (undocumented)
    afterRemoveRow(): TableOperation | null;
    // (undocumented)
    protected applyToCellRange(range: CellRange): CellRange | null;
    // (undocumented)
    protected applyToTable(table: FlowTable): FlowTable;
    static readonly classType: Type<FormatTable>;
    static fromData(input: FormatTableData): FormatTable;
    // (undocumented)
    protected invertForTable(): FlowOperation | null;
    // (undocumented)
    protected mergeNextInSameTable(next: TableOperation): FlowOperation | null;
    // (undocumented)
    protected transformInSameTable(other: TableOperation): FlowOperation | null;
}

// @public
export const FormatTableBase: RecordConstructor<FormatTableProps, TableOperation, FormatTableData>;

// @public @sealed
export class FormatTableColumn extends FormatTableColumnBase implements FormatTableColumnProps {
    // (undocumented)
    afterInsertColumn(index: number, count: number): TableOperation | null;
    // (undocumented)
    afterInsertRow(): TableOperation | null;
    // (undocumented)
    afterRemoveColumn(index: number, count: number): TableOperation | null;
    // (undocumented)
    afterRemoveRow(): TableOperation | null;
    // (undocumented)
    protected applyToCellRange(range: CellRange): CellRange | null;
    // (undocumented)
    protected applyToTable(table: FlowTable): FlowTable;
    static readonly classType: Type<FormatTableColumn>;
    static fromData(input: FormatTableColumnData): FormatTableColumn;
    // (undocumented)
    protected invertForTable(): FlowOperation | null;
    // (undocumented)
    protected mergeNextInSameTable(next: TableOperation): FlowOperation | null;
    // (undocumented)
    protected transformInSameTable(other: TableOperation): FlowOperation | null;
}

// @public
export const FormatTableColumnBase: RecordConstructor<FormatTableColumnProps, TableOperation, FormatTableColumnData>;

// @public
export interface FormatTableColumnData {
    column: number;
    format: "table_column";
    style: TableColumnStyle;
    table: number;
}

// @public
export interface FormatTableColumnProps {
    column: number;
    position: number;
    style: TableColumnStyle;
}

// @public
export interface FormatTableData {
    at: number;
    format: "table";
    style: TableStyle;
}

// @public
export interface FormatTableProps {
    position: number;
    style: TableStyle;
}

// @public @sealed
export class FormatText extends FormatTextBase implements Readonly<FormatTextProps> {
    afterInsertFlow(other: FlowRange): FlowOperation | null;
    afterRemoveFlow(other: FlowRange): FlowOperation | null;
    // @override
    applyToContent(content: FlowContent, theme?: FlowTheme): FlowContent;
    // @override
    applyToSelection(selection: FlowSelection): FlowSelection;
    static readonly classType: Type<FormatText>;
    static fromData(data: FormatTextData): FormatText;
    // @override
    invert(content: FlowContent): FlowOperation | null;
    mergeNext(next: FlowOperation): FlowOperation | null;
    // @override
    transform(other: FlowOperation): FlowOperation | null;
}

// @public
export const FormatTextBase: RecordConstructor<FormatTextProps, FlowOperation, FormatTextData>;

// @public
export interface FormatTextData extends FormatTextProps {
    format: "text";
}

// @public
export interface FormatTextProps {
    range: FlowRange;
    style: TextStyle;
}

// @public
export const HORIZONTAL_ALIGNMENTS: readonly ["start", "center", "end", "justify"];

// @public
export type HorizontalAlignment = (typeof HORIZONTAL_ALIGNMENTS)[number];

// @public (undocumented)
export class HttpFlowSyncProtocol implements FlowSyncProtocol {
    constructor(url: string, fetcher?: BasicFetch);
    // (undocumented)
    read(): Promise<FlowSyncSnapshot | null>;
    // (undocumented)
    sync(input: FlowSyncInput): Promise<FlowSyncOutput | null>;
    // (undocumented)
    get url(): string;
}

// @public @sealed
export class ImageSource extends ImageSourceBase implements Readonly<ImageSourceProps> {
    static readonly classType: Type<RecordObject<Omit<{
    url: string;
    width: number;
    height: number;
    placeholder: string;
    upload: string;
    }, "placeholder" | "upload"> & Partial<Pick<{
    url: string;
    width: number;
    height: number;
    placeholder: string;
    upload: string;
    }, "placeholder" | "upload">>, Omit<{
    url: string;
    width: number;
    height: number;
    placeholder: string;
    upload: string;
    }, "placeholder" | "upload"> & Partial<Pick<{
    url: string;
    width: number;
    height: number;
    placeholder: string;
    upload: string;
    }, "placeholder" | "upload">>> & Equatable & Readonly<Omit<{
    url: string;
    width: number;
    height: number;
    placeholder: string;
    upload: string;
    }, "placeholder" | "upload"> & Partial<Pick<{
    url: string;
    width: number;
    height: number;
    placeholder: string;
    upload: string;
    }, "placeholder" | "upload">>> & ImageSource>;
}

// @public
export const ImageSourceBase: RecordConstructor<Omit<{
url: string;
width: number;
height: number;
placeholder: string;
upload: string;
}, "placeholder" | "upload"> & Partial<Pick<{
url: string;
width: number;
height: number;
placeholder: string;
upload: string;
}, "placeholder" | "upload">>, Object, Omit<{
url: string;
width: number;
height: number;
placeholder: string;
upload: string;
}, "placeholder" | "upload"> & Partial<Pick<{
url: string;
width: number;
height: number;
placeholder: string;
upload: string;
}, "placeholder" | "upload">>>;

// @public
export interface ImageSourceProps {
    height: number;
    placeholder?: string;
    upload?: string;
    url: string;
    width: number;
}

// @public
export abstract class InlineNode extends FlowNode {
    completeUpload(id: string, url: string): FlowNode;
    formatBox(): this;
    formatParagraph(): this;
    formatText(style: TextStyle): this;
    // @override
    getUniformParagraphStyle(): ParagraphStyle | null;
    // @override
    getUniformTextStyle(theme?: ParagraphTheme): TextStyle;
    abstract set(key: "style", value: TextStyle): this;
    abstract readonly style: TextStyle;
    unformatAmbient(theme: ParagraphTheme): this;
    unformatBox(): this;
    unformatParagraph(): this;
    unformatText(style: TextStyle): this;
}

// @public @sealed
export class InsertContent extends InsertContentBase implements InsertContentProps {
    afterInsertFlow(other: FlowRange): FlowOperation | null;
    afterRemoveFlow(other: FlowRange): FlowOperation | null;
    applyToContent(content: FlowContent, theme?: FlowTheme): FlowContent;
    // @override
    applyToSelection(selection: FlowSelection, mine: boolean): FlowSelection | null;
    static readonly classType: Type<InsertContent>;
    static fromData(data: InsertContentData): InsertContent;
    invert(): FlowOperation | null;
    mergeNext(next: FlowOperation): FlowOperation | null;
    toData(): InsertContentData;
    transform(other: FlowOperation): FlowOperation | null;
    // @internal
    translate(delta: number): InsertContent;
}

// @public
export const InsertContentBase: RecordConstructor<InsertContentProps, FlowOperation, InsertContentData>;

// @public
export interface InsertContentData {
    at: number;
    insert: FlowContent;
}

// @public
export interface InsertContentProps {
    content: FlowContent;
    position: number;
}

// @public @sealed
export class InsertTableColumn extends InsertTableColumnBase implements InsertTableColumnProps {
    // (undocumented)
    afterInsertColumn(index: number, count: number): TableOperation | null;
    // (undocumented)
    afterInsertRow(): TableOperation | null;
    // (undocumented)
    afterRemoveColumn(index: number, count: number): TableOperation | null;
    // (undocumented)
    afterRemoveRow(): TableOperation | null;
    // (undocumented)
    protected applyToCellRange(range: CellRange): CellRange | null;
    // (undocumented)
    protected applyToTable(table: FlowTable): FlowTable;
    static readonly classType: Type<InsertTableColumn>;
    static fromData(input: InsertTableColumnData): InsertTableColumn;
    // (undocumented)
    protected invertForTable(): FlowOperation | null;
    // (undocumented)
    protected mergeNextInSameTable(): FlowOperation | null;
    // (undocumented)
    protected transformInSameTable(other: TableOperation): FlowOperation | null;
}

// @public
export const InsertTableColumnBase: RecordConstructor<InsertTableColumnProps, TableOperation, InsertTableColumnData>;

// @public
export interface InsertTableColumnData {
    column: number;
    count?: number;
    insert: "table_column";
    table: number;
}

// @public
export interface InsertTableColumnProps {
    column: number;
    count: number;
    position: number;
}

// @public @sealed
export class InsertTableRow extends InsertTableRowBase implements InsertTableRowProps {
    // (undocumented)
    afterInsertColumn(): TableOperation | null;
    // (undocumented)
    afterInsertRow(index: number, count: number): TableOperation | null;
    // (undocumented)
    afterRemoveColumn(): TableOperation | null;
    // (undocumented)
    afterRemoveRow(index: number, count: number): TableOperation | null;
    // (undocumented)
    protected applyToCellRange(range: CellRange): CellRange | null;
    // (undocumented)
    protected applyToTable(table: FlowTable): FlowTable;
    static readonly classType: Type<InsertTableRow>;
    static fromData(input: InsertTableRowData): InsertTableRow;
    // (undocumented)
    protected invertForTable(): FlowOperation | null;
    // (undocumented)
    protected mergeNextInSameTable(): FlowOperation | null;
    // (undocumented)
    protected transformInSameTable(other: TableOperation): FlowOperation | null;
}

// @public
export const InsertTableRowBase: RecordConstructor<InsertTableRowProps, TableOperation, InsertTableRowData>;

// @public
export interface InsertTableRowData {
    count?: number;
    insert: "table_row";
    row: number;
    table: number;
}

// @public
export interface InsertTableRowProps {
    count: number;
    position: number;
    row: number;
}

// @public
export abstract class Interaction {
    static readonly baseType: Type<Interaction>;
    static fromJsonValue(value: JsonValue): Interaction;
    toJsonValue(): JsonValue;
}

// @public @sealed
export class LineBreak extends LineBreakBase implements LineBreakProps {
    constructor(props?: LineBreakProps);
    static readonly classType: Type<LineBreak>;
    static fromData(data: LineBreakData): LineBreak;
    readonly size = 1;
}

// @public
export const LineBreakBase: RecordConstructor<LineBreakProps, InlineNode, LineBreakData>;

// @public
export interface LineBreakData {
    break: "line";
    style?: TextStyle;
}

// @public
export interface LineBreakProps {
    style: TextStyle;
}

// @public
export const LIST_COUNTER_ACTIONS: readonly ["auto", "reset", "resume"];

// @public
export const LIST_MARKER_KINDS: readonly ["ordered", "decimal", "lower-alpha", "upper-alpha", "lower-roman", "upper-roman", "unordered", "disc", "circle", "square", "dash"];

// @public
export type ListCounterAction = (typeof LIST_COUNTER_ACTIONS)[number];

// @public
export type ListMarkerKind = OrderedListMarkerKind | UnorderedListMarkerKind;

// @public
export const ListMarkerKindType: Type<ListMarkerKind>;

// @public
export const mapNotNull: <A extends readonly unknown[], T>(array: A, callback: (value: A[number], index: number) => T | null | undefined) => Exclude<T, null | undefined>[];

// @public @sealed
export class MergeTableCell extends MergeTableCellBase implements MergeTableCellProps {
    // (undocumented)
    afterInsertAxis(axis: "row" | "column", index: number, count: number): TableOperation | null;
    // (undocumented)
    afterInsertColumn(index: number, count: number): TableOperation | null;
    // (undocumented)
    afterInsertRow(index: number, count: number): TableOperation | null;
    // (undocumented)
    afterRemoveAxis(axis: "row" | "column", index: number, count: number): TableOperation | null;
    // (undocumented)
    afterRemoveColumn(index: number, count: number): TableOperation | null;
    // (undocumented)
    afterRemoveRow(index: number, count: number): TableOperation | null;
    // (undocumented)
    protected applyToCellRange(range: CellRange): CellRange | null;
    // (undocumented)
    protected applyToTable(table: FlowTable): FlowTable;
    static readonly classType: Type<MergeTableCell>;
    static fromData(input: MergeTableCellData): MergeTableCell;
    // (undocumented)
    getAxisRange(axis: "row" | "column"): FlowRange;
    // (undocumented)
    protected invertForTable(): FlowOperation | null;
    // (undocumented)
    protected mergeNextInSameTable(): FlowOperation | null;
    // (undocumented)
    setAxisRange(axis: "row" | "column", range: FlowRange | null): TableOperation | null;
    // (undocumented)
    protected transformInSameTable(other: TableOperation): FlowOperation | null;
}

// @public
export const MergeTableCellBase: RecordConstructor<MergeTableCellProps, TableOperation, MergeTableCellData>;

// @public
export interface MergeTableCellData {
    cell: CellPosition;
    colSpan: number;
    merge: "table_cell";
    rowSpan: number;
    table: number;
}

// @public
export interface MergeTableCellProps {
    cell: CellPosition;
    colSpan: number;
    position: number;
    rowSpan: number;
}

// @public
export abstract class NestedFlowOperation extends FlowOperation {
    // @override
    afterInsertFlow(range: FlowRange): FlowOperation | null;
    // @override
    afterRemoveFlow(range: FlowRange): FlowOperation | null;
    applyToContent(content: FlowContent, theme?: FlowTheme): FlowContent;
    // @override
    applyToSelection(selection: FlowSelection, mine: boolean): FlowSelection | null;
    protected abstract createReplacementNode(content: FlowContent, before: FlowNode): FlowNode;
    protected getInnerContent(outer: FlowContent): FlowContent;
    protected abstract getInnerContentFromNode(node: FlowNode): FlowContent;
    protected abstract getInnerThemeFromNode(node: FlowNode, outer?: FlowTheme): FlowTheme;
    protected getTargetNode(outer: FlowContent): FlowNode;
    abstract inner: FlowOperation;
    invert(content: FlowContent): FlowOperation | null;
    abstract position: number;
    abstract set(key: "position", value: number): this;
    abstract set(key: "inner", value: FlowOperation): this;
    transform(other: FlowOperation): FlowOperation | null;
}

// @public
export abstract class NestedFlowSelection extends FlowSelection {
    // @override
    afterInsertFlow(range: FlowRange): FlowSelection | null;
    // @override
    afterRemoveFlow(range: FlowRange, mine: boolean): FlowSelection | null;
    // @override
    formatBox(style: BoxStyle, options?: TargetOptions): FlowOperation | null;
    // @override
    formatList(content: FlowContent, kind: "ordered" | "unordered" | null): FlowOperation | null;
    // @override
    formatParagraph(style: ParagraphStyle, options?: TargetOptions): FlowOperation | null;
    // @override
    formatTable(style: TableStyle, options?: TargetOptions): FlowOperation | null;
    // @override
    formatTableColumn(style: TableColumnStyle, options?: TargetOptions): FlowOperation | null;
    // @override
    formatText(style: TextStyle, options?: TargetOptions): FlowOperation | null;
    protected getInnerContent(outer: FlowContent): FlowContent;
    protected abstract getInnerContentFromNode(node: FlowNode): FlowContent;
    protected abstract getInnerSelection(): FlowSelection;
    protected getInnerTheme(outerContent: FlowContent, outerTheme?: FlowTheme): FlowTheme;
    protected abstract getInnerThemeFromNode(node: FlowNode, outer?: FlowTheme): FlowTheme;
    protected abstract getOuterOperation(inner: FlowOperation): FlowOperation;
    protected getSelectedNode(outer: FlowContent): FlowNode;
    // @override
    getUniformBoxStyle(content: FlowContent, theme?: FlowTheme, diff?: Set<keyof BoxStyleProps>): BoxStyle;
    // @override
    getUniformParagraphStyle(content: FlowContent, theme?: FlowTheme, diff?: Set<keyof ParagraphStyleProps>): ParagraphStyle;
    // @override
    getUniformTextStyle(content: FlowContent, theme?: FlowTheme, diff?: Set<keyof TextStyleProps>): TextStyle;
    // @override
    incrementListLevel(content: FlowContent, delta?: number): FlowOperation | null;
    // @override
    insert(content: FlowContent, options?: TargetOptions): FlowOperation | null;
    // @override
    insertTableColumnAfter(content: FlowContent, count?: number): FlowOperation | null;
    // @override
    insertTableColumnBefore(content: FlowContent, count?: number): FlowOperation | null;
    // @override
    insertTableRowAfter(content: FlowContent, count?: number): FlowOperation | null;
    // @override
    insertTableRowBefore(content: FlowContent, count?: number): FlowOperation | null;
    // @override
    get isCollapsed(): boolean;
    // @override
    mergeTableCell(content: FlowContent): FlowOperation | null;
    abstract position: number;
    // @override
    remove(options?: RemoveFlowSelectionOptions): FlowOperation | null;
    // @override
    removeTableColumn(content: FlowContent): FlowOperation | null;
    // @override
    removeTableRow(content: FlowContent): FlowOperation | null;
    abstract set(key: "position", value: number): this;
    // @override
    setDynamicTextExpression(content: FlowContent, expression: string): FlowOperation | null;
    // @override
    setIcon(content: FlowContent, data: string): FlowOperation | null;
    // @override
    setImageSource(content: FlowContent, source: ImageSource): FlowOperation | null;
    protected abstract setInnerSelection(value: FlowSelection): NestedFlowSelection;
    // @override
    splitTableCell(content: FlowContent): FlowOperation | null;
    // @override
    transformRanges(transform: (range: FlowRange, options?: TargetOptions) => FlowRange | null, options?: TargetOptions): FlowSelection | null;
    // @override
    unformatBox(style: BoxStyle, options?: TargetOptions): FlowOperation | null;
    // @override
    unformatParagraph(style: ParagraphStyle, options?: TargetOptions): FlowOperation | null;
    // @override
    unformatTable(style: TableStyle, options?: TargetOptions): FlowOperation | null;
    // @override
    unformatTableColumn(style: TableColumnStyle, options?: TargetOptions): FlowOperation | null;
    // @override
    unformatText(style: TextStyle, options?: TargetOptions): FlowOperation | null;
    // @internal
    updateInner(callback: (inner: FlowSelection) => FlowSelection | null): FlowSelection | null;
    // @override
    visitRanges(callback: (range: FlowRange | CellRange, options: VisitRangeOptions) => void, options?: Partial<VisitRangeOptions>): void;
}

// @public
export type NotNull<T> = Exclude<T, null | undefined>;

// @public @sealed
export class OpenUrl extends OpenUrlBase {
    static readonly classType: Type<OpenUrl>;
    static fromData(data: string): OpenUrl;
}

// @public
export const OpenUrlBase: RecordConstructor<OpenUrlProps, Interaction, string>;

// @public
export interface OpenUrlProps {
    url: string;
}

// @public
export const ORDERED_LIST_MARKER_KINDS: readonly ["ordered", "decimal", "lower-alpha", "upper-alpha", "lower-roman", "upper-roman"];

// @public
export type OrderedListMarkerKind = (typeof ORDERED_LIST_MARKER_KINDS)[number];

// @public
export const OrderedListMarkerKindType: Type<ListMarkerKind>;

// @public
export const PARAGRAPH_VARIANTS: readonly ["normal", "h1", "h2", "h3", "h4", "h5", "h6", "title", "subtitle", "preamble", "code"];

// @public @sealed
export class ParagraphBreak extends ParagraphBreakBase implements ParagraphBreakProps {
    constructor(props?: ParagraphBreakProps);
    static readonly classType: Type<ParagraphBreak>;
    completeUpload(): this;
    formatBox(): this;
    formatParagraph(style: ParagraphStyle): this;
    formatText(): this;
    static fromData(data: ParagraphBreakData): ParagraphBreak;
    // @override
    getUniformParagraphStyle(theme?: ParagraphTheme): ParagraphStyle | null;
    // @override
    getUniformTextStyle(theme?: ParagraphTheme): TextStyle;
    readonly size = 1;
    unformatAmbient(theme: ParagraphTheme): this;
    unformatBox(): this;
    unformatParagraph(style: ParagraphStyle): this;
    unformatText(): this;
}

// @public
export const ParagraphBreakBase: RecordConstructor<ParagraphBreakProps, FlowNode, ParagraphBreakData>;

// @public
export interface ParagraphBreakData {
    break: "para";
    style?: ParagraphStyle;
}

// @public
export interface ParagraphBreakProps {
    style: ParagraphStyle;
}

// @public @sealed
export class ParagraphStyle extends ParagraphStyleBase implements Readonly<ParagraphStyleProps> {
    constructor(props?: ParagraphStyleProps);
    static readonly classType: Type<RecordObject<Partial<{
    alignment: "start" | "center" | "end" | "justify";
    direction: "ltr" | "rtl";
    variant: "normal" | "h1" | "h2" | "h3" | "h4" | "h5" | "h6" | "title" | "subtitle" | "preamble" | "code";
    lineSpacing: number;
    spaceBefore: number;
    spaceAfter: number;
    listLevel: number;
    listMarker: ListMarkerKind;
    hideListMarker: boolean;
    listCounter: number | "auto" | "reset" | "resume";
    listCounterPrefix: string;
    listCounterSuffix: string;
    }>, Partial<{
    alignment: "start" | "center" | "end" | "justify";
    direction: "ltr" | "rtl";
    variant: "normal" | "h1" | "h2" | "h3" | "h4" | "h5" | "h6" | "title" | "subtitle" | "preamble" | "code";
    lineSpacing: number;
    spaceBefore: number;
    spaceAfter: number;
    listLevel: number;
    listMarker: ListMarkerKind;
    hideListMarker: boolean;
    listCounter: number | "auto" | "reset" | "resume";
    listCounterPrefix: string;
    listCounterSuffix: string;
    }>> & Equatable & Readonly<Partial<{
        alignment: "start" | "center" | "end" | "justify";
        direction: "ltr" | "rtl";
        variant: "normal" | "h1" | "h2" | "h3" | "h4" | "h5" | "h6" | "title" | "subtitle" | "preamble" | "code";
        lineSpacing: number;
        spaceBefore: number;
        spaceAfter: number;
        listLevel: number;
        listMarker: ListMarkerKind;
        hideListMarker: boolean;
        listCounter: number | "auto" | "reset" | "resume";
        listCounterPrefix: string;
        listCounterSuffix: string;
    }>> & ParagraphStyle>;
    static get empty(): ParagraphStyle;
    get isEmpty(): boolean;
}

// @public
export const ParagraphStyleBase: RecordConstructor<Partial<{
alignment: "start" | "center" | "end" | "justify";
direction: "ltr" | "rtl";
variant: "normal" | "h1" | "h2" | "h3" | "h4" | "h5" | "h6" | "title" | "subtitle" | "preamble" | "code";
lineSpacing: number;
spaceBefore: number;
spaceAfter: number;
listLevel: number;
listMarker: ListMarkerKind;
hideListMarker: boolean;
listCounter: number | "auto" | "reset" | "resume";
listCounterPrefix: string;
listCounterSuffix: string;
}>, Object, Partial<{
alignment: "start" | "center" | "end" | "justify";
direction: "ltr" | "rtl";
variant: "normal" | "h1" | "h2" | "h3" | "h4" | "h5" | "h6" | "title" | "subtitle" | "preamble" | "code";
lineSpacing: number;
spaceBefore: number;
spaceAfter: number;
listLevel: number;
listMarker: ListMarkerKind;
hideListMarker: boolean;
listCounter: number | "auto" | "reset" | "resume";
listCounterPrefix: string;
listCounterSuffix: string;
}>>;

// @public
export interface ParagraphStyleProps {
    alignment?: HorizontalAlignment;
    direction?: ReadingDirection;
    hideListMarker?: boolean;
    lineSpacing?: number;
    listCounter?: number | ListCounterAction;
    listCounterPrefix?: string;
    listCounterSuffix?: string;
    listLevel?: number;
    listMarker?: ListMarkerKind;
    spaceAfter?: number;
    spaceBefore?: number;
    variant?: ParagraphVariant;
}

// @public
export abstract class ParagraphTheme {
    abstract getAmbientParagraphStyle(): ParagraphStyle;
    abstract getAmbientTextStyle(): TextStyle;
    abstract getFlowTheme(): FlowTheme;
    abstract getLinkStyle(): TextStyle;
    abstract getNextVariant(): ParagraphVariant;
}

// @public
export type ParagraphVariant = (typeof PARAGRAPH_VARIANTS)[number];

// @public
export const ParagraphVariantType: Type<ParagraphVariant>;

// @public
export const PREDEFINED_ICONS: readonly ["information", "success", "warning", "error"];

// @public
export type PredefinedIcon = (typeof PREDEFINED_ICONS)[number];

// @public
export const PredefinedIconType: Type<PredefinedIcon>;

// @public
export const READING_DIRECTIONS: readonly ["ltr", "rtl"];

// @public
export type ReadingDirection = (typeof READING_DIRECTIONS)[number];

// @public
export interface RemoveFlowSelectionOptions extends TargetOptions {
    whenCollapsed?: "removeBackward" | "removeForward" | "noop";
}

// @public @sealed
export class RemoveRange extends RemoveRangeBase implements Readonly<RemoveRangeProps> {
    afterInsertFlow(other: FlowRange): FlowOperation | null;
    afterRemoveFlow(other: FlowRange): FlowOperation | null;
    // @override
    applyToContent(content: FlowContent): FlowContent;
    // @override
    applyToSelection(selection: FlowSelection, mine: boolean): FlowSelection | null;
    static readonly classType: Type<RemoveRange>;
    static fromData(data: RemoveRangeData): RemoveRange;
    // @override
    invert(content: FlowContent): InsertContent;
    mergeNext(next: FlowOperation): FlowOperation | null;
    // @override
    transform(other: FlowOperation): FlowOperation | null;
}

// @public
export const RemoveRangeBase: RecordConstructor<RemoveRangeProps, FlowOperation, RemoveRangeData>;

// @public
export interface RemoveRangeData {
    remove: FlowRange;
}

// @public
export interface RemoveRangeProps {
    range: FlowRange;
}

// @public @sealed
export class RemoveTableColumn extends RemoveTableColumnBase implements RemoveTableColumnProps {
    // (undocumented)
    afterInsertColumn(index: number, count: number): TableOperation | null;
    // (undocumented)
    afterInsertRow(): TableOperation | null;
    // (undocumented)
    afterRemoveColumn(index: number, count: number): TableOperation | null;
    // (undocumented)
    afterRemoveRow(): TableOperation | null;
    // (undocumented)
    protected applyToCellRange(range: CellRange): CellRange | null;
    // (undocumented)
    protected applyToTable(table: FlowTable): FlowTable;
    static readonly classType: Type<RemoveTableColumn>;
    static fromData(input: RemoveTableColumnData): RemoveTableColumn;
    // (undocumented)
    protected invertForTable(): FlowOperation | null;
    // (undocumented)
    protected mergeNextInSameTable(): FlowOperation | null;
    // (undocumented)
    protected transformInSameTable(other: TableOperation): FlowOperation | null;
}

// @public
export const RemoveTableColumnBase: RecordConstructor<RemoveTableColumnProps, TableOperation, RemoveTableColumnData>;

// @public
export interface RemoveTableColumnData {
    column: number;
    count?: number;
    remove: "table_column";
    table: number;
}

// @public
export interface RemoveTableColumnProps {
    column: number;
    count: number;
    position: number;
}

// @public @sealed
export class RemoveTableRow extends RemoveTableRowBase implements RemoveTableRowProps {
    // (undocumented)
    afterInsertColumn(): TableOperation | null;
    // (undocumented)
    afterInsertRow(index: number, count: number): TableOperation | null;
    // (undocumented)
    afterRemoveColumn(): TableOperation | null;
    // (undocumented)
    afterRemoveRow(index: number, count: number): TableOperation | null;
    // (undocumented)
    protected applyToCellRange(range: CellRange): CellRange | null;
    // (undocumented)
    protected applyToTable(table: FlowTable): FlowTable;
    static readonly classType: Type<RemoveTableRow>;
    static fromData(input: RemoveTableRowData): RemoveTableRow;
    // (undocumented)
    protected invertForTable(): FlowOperation | null;
    // (undocumented)
    protected mergeNextInSameTable(): FlowOperation | null;
    // (undocumented)
    protected transformInSameTable(other: TableOperation): FlowOperation | null;
}

// @public
export const RemoveTableRowBase: RecordConstructor<RemoveTableRowProps, TableOperation, RemoveTableRowData>;

// @public
export interface RemoveTableRowData {
    count?: number;
    remove: "table_row";
    row: number;
    table: number;
}

// @public
export interface RemoveTableRowProps {
    count: number;
    position: number;
    row: number;
}

// @public @sealed
export class ResetContent extends ResetContentBase implements ResetContentProps {
    afterInsertFlow(): FlowOperation | null;
    afterRemoveFlow(): FlowOperation | null;
    // @override
    applyToContent(): FlowContent;
    // @override
    applyToSelection(): FlowSelection;
    static readonly classType: Type<ResetContent>;
    static fromData(input: ResetContentData): ResetContent;
    // @override
    invert(content: FlowContent): FlowOperation | null;
    mergeNext(next: FlowOperation): FlowOperation | null;
    // @override
    transform(): FlowOperation | null;
}

// @public
export const ResetContentBase: RecordConstructor<ResetContentProps, FlowOperation, ResetContentData>;

// @public
export interface ResetContentData {
    content: FlowContent;
    reset: "content";
}

// @public
export interface ResetContentProps {
    content: FlowContent;
}

// @public @sealed
export class RunScript extends RunScriptBase {
    static readonly classType: Type<RecordObject<RunScriptProps, RunScriptProps> & Equatable & Readonly<RunScriptProps> & RunScript>;
}

// @public
export const RunScriptBase: RecordConstructor<RunScriptProps, Interaction, RunScriptProps>;

// @public
export interface RunScriptProps {
    script: string;
}

// @public @sealed
export class SetDynamicTextExpression extends SetDynamicTextExpressionBase implements SetDynamicTextExpressionProps {
    afterInsertFlow(range: FlowRange): FlowOperation | null;
    afterRemoveFlow(range: FlowRange): FlowOperation | null;
    // @override
    applyToContent(content: FlowContent): FlowContent;
    // @override
    applyToSelection(selection: FlowSelection): FlowSelection;
    static readonly classType: Type<SetDynamicTextExpression>;
    static fromData(data: SetDynamicTextExpressionData): SetDynamicTextExpression;
    // @override
    invert(content: FlowContent): FlowOperation | null;
    mergeNext(next: FlowOperation): FlowOperation | null;
    // @override
    transform(other: FlowOperation): FlowOperation | null;
}

// @public
export const SetDynamicTextExpressionBase: RecordConstructor<SetDynamicTextExpressionProps, FlowOperation, SetDynamicTextExpressionData>;

// @public
export interface SetDynamicTextExpressionData {
    at: number;
    set: "dynamic_text_expression";
    value: string;
}

// @public
export interface SetDynamicTextExpressionProps {
    expression: string;
    position: number;
}

// @public @sealed
export class SetIcon extends SetIconBase implements SetIconProps {
    afterInsertFlow(range: FlowRange): FlowOperation | null;
    afterRemoveFlow(range: FlowRange): FlowOperation | null;
    // @override
    applyToContent(content: FlowContent): FlowContent;
    // @override
    applyToSelection(selection: FlowSelection): FlowSelection;
    static readonly classType: Type<SetIcon>;
    static fromData(input: SetIconData): SetIcon;
    // @override
    invert(content: FlowContent): FlowOperation | null;
    mergeNext(next: FlowOperation): FlowOperation | null;
    // @override
    transform(other: FlowOperation): FlowOperation | null;
}

// @public
export const SetIconBase: RecordConstructor<SetIconProps, FlowOperation, SetIconData>;

// @public
export interface SetIconData {
    at: number;
    data: string;
    set: "icon";
}

// @public
export interface SetIconProps {
    data: string;
    position: number;
}

// @public @sealed
export class SetImageSource extends SetImageSourceBase implements SetImageSourceProps {
    afterInsertFlow(range: FlowRange): FlowOperation | null;
    afterRemoveFlow(range: FlowRange): FlowOperation | null;
    // @override
    applyToContent(content: FlowContent): FlowContent;
    // @override
    applyToSelection(selection: FlowSelection): FlowSelection;
    static readonly classType: Type<SetImageSource>;
    static fromData(data: SetImageSourceData): SetImageSource;
    // @override
    invert(content: FlowContent): FlowOperation | null;
    mergeNext(next: FlowOperation): FlowOperation | null;
    // @override
    transform(other: FlowOperation): FlowOperation | null;
}

// @public
export const SetImageSourceBase: RecordConstructor<SetImageSourceProps, FlowOperation, SetImageSourceData>;

// @public
export interface SetImageSourceData {
    at: number;
    set: "image_source";
    value: ImageSource;
}

// @public
export interface SetImageSourceProps {
    position: number;
    value: ImageSource;
}

// @public @sealed
export class SplitTableCell extends SplitTableCellBase implements SplitTableCellProps {
    // (undocumented)
    afterInsertAxis(axis: "row" | "column", index: number, count: number): TableOperation | null;
    // (undocumented)
    afterInsertColumn(index: number, count: number): TableOperation | null;
    // (undocumented)
    afterInsertRow(index: number, count: number): TableOperation | null;
    // (undocumented)
    afterRemoveAxis(axis: "row" | "column", index: number, count: number): TableOperation | null;
    // (undocumented)
    afterRemoveColumn(index: number, count: number): TableOperation | null;
    // (undocumented)
    afterRemoveRow(index: number, count: number): TableOperation | null;
    // (undocumented)
    protected applyToCellRange(range: CellRange): CellRange | null;
    // (undocumented)
    protected applyToTable(table: FlowTable): FlowTable;
    static readonly classType: Type<SplitTableCell>;
    static fromData(input: SplitTableCellData): SplitTableCell;
    // (undocumented)
    protected invertForTable(table: FlowTable): FlowOperation | null;
    // (undocumented)
    protected mergeNextInSameTable(): FlowOperation | null;
    // (undocumented)
    protected transformInSameTable(other: TableOperation): FlowOperation | null;
}

// @public
export const SplitTableCellBase: RecordConstructor<SplitTableCellProps, TableOperation, SplitTableCellData>;

// @public
export interface SplitTableCellData {
    cell: CellPosition;
    split: "table_cell";
    table: number;
}

// @public
export interface SplitTableCellProps {
    cell: CellPosition;
    position: number;
}

// @public @sealed
export class StartMarkup extends StartMarkupBase implements StartMarkupProps {
    constructor(props: StartMarkupProps);
    static readonly classType: Type<StartMarkup>;
    static fromData(data: StartMarkupData): StartMarkup;
    readonly size = 1;
}

// @public
export const StartMarkupBase: RecordConstructor<StartMarkupProps, InlineNode, StartMarkupData>;

// @public
export interface StartMarkupData {
    // (undocumented)
    start_markup: string;
    // (undocumented)
    style?: TextStyle;
}

// @public
export interface StartMarkupProps {
    // (undocumented)
    style: TextStyle;
    // (undocumented)
    tag: string;
}

// @public @sealed
export class TableColumnStyle extends TableColumnStyleBase implements Readonly<TableColumnStyleProps> {
    constructor(props?: TableColumnStyleProps);
    static readonly classType: Type<RecordObject<Partial<{
    width: number;
    }>, Partial<{
    width: number;
    }>> & Equatable & Readonly<Partial<{
    width: number;
    }>> & TableColumnStyle>;
    static get empty(): TableColumnStyle;
    get isEmpty(): boolean;
}

// @public
export const TableColumnStyleBase: RecordConstructor<Partial<{
width: number;
}>, Object, Partial<{
width: number;
}>>;

// @public
export interface TableColumnStyleProps {
    // (undocumented)
    width?: number;
}

// @public @sealed
export abstract class TableOperation extends FlowOperation {
    // (undocumented)
    abstract afterInsertColumn(index: number, count: number): TableOperation | null;
    afterInsertFlow(range: FlowRange): FlowOperation | null;
    // (undocumented)
    abstract afterInsertRow(index: number, count: number): TableOperation | null;
    // (undocumented)
    abstract afterRemoveColumn(index: number, count: number): TableOperation | null;
    afterRemoveFlow(range: FlowRange): FlowOperation | null;
    // (undocumented)
    abstract afterRemoveRow(index: number, count: number): TableOperation | null;
    // @internal (undocumented)
    protected abstract applyToCellRange(range: CellRange, mine: boolean): CellRange | null;
    // @override
    applyToContent(content: FlowContent): FlowContent;
    // @override
    applyToSelection(selection: FlowSelection, mine: boolean): FlowSelection | null;
    // @internal (undocumented)
    protected abstract applyToTable(table: FlowTable): FlowTable;
    // @override
    invert(content: FlowContent): FlowOperation | null;
    // @internal (undocumented)
    protected abstract invertForTable(table: FlowTable): FlowOperation | null;
    mergeNext(next: FlowOperation): FlowOperation | null;
    // @internal (undocumented)
    protected abstract mergeNextInSameTable(next: TableOperation): FlowOperation | null;
    abstract readonly position: number;
    abstract set(key: "position", value: number): this;
    // @override
    transform(other: FlowOperation): FlowOperation | null;
    // @internal (undocumented)
    protected abstract transformInSameTable(other: TableOperation): FlowOperation | null;
}

// @public @sealed
export class TableStyle extends TableStyleBase implements Readonly<TableStyleProps> {
    constructor(props?: TableStyleProps);
    static get ambient(): TableStyle;
    static readonly classType: Type<RecordObject<Partial<{
    inline: boolean;
    }>, Partial<{
    inline: boolean;
    }>> & Equatable & Readonly<Partial<{
    inline: boolean;
    }>> & TableStyle>;
    static get empty(): TableStyle;
    get isEmpty(): boolean;
}

// @public
export const TableStyleBase: RecordConstructor<Partial<{
inline: boolean;
}>, Object, Partial<{
inline: boolean;
}>>;

// @public
export interface TableStyleProps {
    inline?: boolean;
}

// @public
export interface TargetOptions {
    target?: FlowContent;
    theme?: FlowTheme;
}

// @public @sealed
export class TextRun extends TextRunBase implements Readonly<TextRunProps> {
    constructor(props?: TextRunProps);
    after(position: number): TextRun;
    append(value: string): TextRun;
    before(position: number): TextRun;
    static readonly classType: Type<TextRun>;
    static fromData(data: TextRunData): TextRun;
    // @internal
    static merge(first: TextRun, second: TextRun): TextRun;
    static normalizeText(value: unknown): string;
    // @internal
    static shouldMerge(first: TextRun, second: TextRun): boolean;
    readonly size: number;
    split(position: number): [TextRun, TextRun];
}

// @public
export const TextRunBase: RecordConstructor<TextRunProps, InlineNode, TextRunData>;

// @public
export type TextRunData = string | (Pick<TextRunProps, "text"> & Partial<Omit<TextRunProps, "text">>);

// @public
export interface TextRunProps {
    style: TextStyle;
    text: string;
}

// @public @sealed
export class TextStyle extends TextStyleBase implements Readonly<TextStyleProps> {
    constructor(props?: TextStyleProps);
    static readonly classType: Type<RecordObject<Partial<{
    bold: boolean;
    italic: boolean;
    underline: boolean;
    strike: boolean;
    baseline: "normal" | "sub" | "super";
    fontFamily: "body" | "heading" | "monospace";
    fontSize: number;
    link: Interaction | null;
    color: "default" | "subtle" | "primary" | "secondary" | "information" | "success" | "warning" | "error";
    spellcheck: boolean;
    }>, Partial<{
    bold: boolean;
    italic: boolean;
    underline: boolean;
    strike: boolean;
    baseline: "normal" | "sub" | "super";
    fontFamily: "body" | "heading" | "monospace";
    fontSize: number;
    link: Interaction | null;
    color: "default" | "subtle" | "primary" | "secondary" | "information" | "success" | "warning" | "error";
    spellcheck: boolean;
    }>> & Equatable & Readonly<Partial<{
    bold: boolean;
    italic: boolean;
    underline: boolean;
    strike: boolean;
    baseline: "normal" | "sub" | "super";
    fontFamily: "body" | "heading" | "monospace";
    fontSize: number;
    link: Interaction | null;
    color: "default" | "subtle" | "primary" | "secondary" | "information" | "success" | "warning" | "error";
    spellcheck: boolean;
    }>> & TextStyle>;
    static get empty(): TextStyle;
    get isEmpty(): boolean;
}

// @public
export const TextStyleBase: RecordConstructor<Partial<{
bold: boolean;
italic: boolean;
underline: boolean;
strike: boolean;
baseline: "normal" | "sub" | "super";
fontFamily: "body" | "heading" | "monospace";
fontSize: number;
link: Interaction | null;
color: "default" | "subtle" | "primary" | "secondary" | "information" | "success" | "warning" | "error";
spellcheck: boolean;
}>, Object, Partial<{
bold: boolean;
italic: boolean;
underline: boolean;
strike: boolean;
baseline: "normal" | "sub" | "super";
fontFamily: "body" | "heading" | "monospace";
fontSize: number;
link: Interaction | null;
color: "default" | "subtle" | "primary" | "secondary" | "information" | "success" | "warning" | "error";
spellcheck: boolean;
}>>;

// @public
export interface TextStyleProps {
    baseline?: BaselineOffset;
    bold?: boolean;
    color?: FlowColor;
    fontFamily?: FontFamily;
    fontSize?: number;
    italic?: boolean;
    link?: Interaction | null;
    spellcheck?: boolean;
    strike?: boolean;
    underline?: boolean;
}

// @public @sealed
export class UnformatBox extends UnformatBoxBase implements Readonly<UnformatBoxProps> {
    afterInsertFlow(other: FlowRange): FlowOperation | null;
    afterRemoveFlow(other: FlowRange): FlowOperation | null;
    // @override
    applyToContent(content: FlowContent): FlowContent;
    // @override
    applyToSelection(selection: FlowSelection): FlowSelection;
    static readonly classType: Type<UnformatBox>;
    static fromData(data: UnformatBoxData): UnformatBox;
    // @override
    invert(content: FlowContent): FlowOperation | null;
    mergeNext(next: FlowOperation): FlowOperation | null;
    // @override
    transform(other: FlowOperation): FlowOperation | null;
}

// @public
export const UnformatBoxBase: RecordConstructor<UnformatBoxProps, FlowOperation, UnformatBoxData>;

// @public
export interface UnformatBoxData extends UnformatBoxProps {
    unformat: "box";
}

// @public
export interface UnformatBoxProps {
    range: FlowRange;
    style: BoxStyle;
}

// @public @sealed
export class UnformatParagraph extends UnformatParagraphBase implements Readonly<UnformatParagraphProps> {
    afterInsertFlow(other: FlowRange): FlowOperation | null;
    afterRemoveFlow(other: FlowRange): FlowOperation | null;
    // @override
    applyToContent(content: FlowContent): FlowContent;
    // @override
    applyToSelection(selection: FlowSelection): FlowSelection;
    static readonly classType: Type<UnformatParagraph>;
    static fromData(data: UnformatParagraphData): UnformatParagraph;
    // @override
    invert(content: FlowContent): FlowOperation | null;
    mergeNext(next: FlowOperation): FlowOperation | null;
    // @override
    transform(other: FlowOperation): FlowOperation | null;
}

// @public
export const UnformatParagraphBase: RecordConstructor<UnformatParagraphProps, FlowOperation, UnformatParagraphData>;

// @public
export interface UnformatParagraphData extends UnformatParagraphProps {
    unformat: "para";
}

// @public
export interface UnformatParagraphProps {
    range: FlowRange;
    style: ParagraphStyle;
}

// @public @sealed
export class UnformatTable extends UnformatTableBase implements UnformatTableProps {
    // (undocumented)
    afterInsertColumn(): TableOperation | null;
    // (undocumented)
    afterInsertRow(): TableOperation | null;
    // (undocumented)
    afterRemoveColumn(): TableOperation | null;
    // (undocumented)
    afterRemoveRow(): TableOperation | null;
    // (undocumented)
    protected applyToCellRange(range: CellRange): CellRange | null;
    // (undocumented)
    protected applyToTable(table: FlowTable): FlowTable;
    static readonly classType: Type<UnformatTable>;
    static fromData(input: UnformatTableData): UnformatTable;
    // (undocumented)
    protected invertForTable(): FlowOperation | null;
    // (undocumented)
    protected mergeNextInSameTable(next: TableOperation): FlowOperation | null;
    // (undocumented)
    protected transformInSameTable(other: TableOperation): FlowOperation | null;
}

// @public
export const UnformatTableBase: RecordConstructor<UnformatTableProps, TableOperation, UnformatTableData>;

// @public @sealed
export class UnformatTableColumn extends UnformatTableColumnBase implements UnformatTableColumnProps {
    // (undocumented)
    afterInsertColumn(index: number, count: number): TableOperation | null;
    // (undocumented)
    afterInsertRow(): TableOperation | null;
    // (undocumented)
    afterRemoveColumn(index: number, count: number): TableOperation | null;
    // (undocumented)
    afterRemoveRow(): TableOperation | null;
    // (undocumented)
    protected applyToCellRange(range: CellRange): CellRange | null;
    // (undocumented)
    protected applyToTable(table: FlowTable): FlowTable;
    static readonly classType: Type<UnformatTableColumn>;
    static fromData(input: UnformatTableColumnData): UnformatTableColumn;
    // (undocumented)
    protected invertForTable(): FlowOperation | null;
    // (undocumented)
    protected mergeNextInSameTable(next: TableOperation): FlowOperation | null;
    // (undocumented)
    protected transformInSameTable(other: TableOperation): FlowOperation | null;
}

// @public
export const UnformatTableColumnBase: RecordConstructor<UnformatTableColumnProps, TableOperation, UnformatTableColumnData>;

// @public
export interface UnformatTableColumnData {
    column: number;
    style: TableColumnStyle;
    table: number;
    unformat: "table_column";
}

// @public
export interface UnformatTableColumnProps {
    column: number;
    position: number;
    style: TableColumnStyle;
}

// @public
export interface UnformatTableData {
    at: number;
    style: TableStyle;
    unformat: "table";
}

// @public
export interface UnformatTableProps {
    position: number;
    style: TableStyle;
}

// @public @sealed
export class UnformatText extends UnformatTextBase implements Readonly<UnformatTextProps> {
    afterInsertFlow(other: FlowRange): FlowOperation | null;
    afterRemoveFlow(other: FlowRange): FlowOperation | null;
    // @override
    applyToContent(content: FlowContent): FlowContent;
    // @override
    applyToSelection(selection: FlowSelection): FlowSelection;
    static readonly classType: Type<UnformatText>;
    static fromData(data: UnformatTextData): UnformatText;
    // @override
    invert(content: FlowContent): FlowOperation | null;
    mergeNext(next: FlowOperation): FlowOperation | null;
    // @override
    transform(other: FlowOperation): FlowOperation | null;
}

// @public
export const UnformatTextBase: RecordConstructor<UnformatTextProps, FlowOperation, UnformatTextData>;

// @public
export interface UnformatTextData extends UnformatTextProps {
    unformat: "text";
}

// @public
export interface UnformatTextProps {
    range: FlowRange;
    style: TextStyle;
}

// @public
export const UNORDERED_LIST_MARKER_KINDS: readonly ["unordered", "disc", "circle", "square", "dash"];

// @public
export type UnorderedListMarkerKind = (typeof UNORDERED_LIST_MARKER_KINDS)[number];

// @public
export const UnorderedListMarkerKindType: Type<ListMarkerKind>;

// @public
export interface VisitRangeOptions extends TargetOptions {
    // (undocumented)
    outer?: NestedFlowSelection;
    // (undocumented)
    parent?: TargetOptions;
    // (undocumented)
    position?: number;
    // (undocumented)
    replace(inner: FlowSelection): FlowSelection | null;
    // (undocumented)
    wrap(inner: FlowSelection | CellRange | FlowRange): FlowSelection | null;
}

```
