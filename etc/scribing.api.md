## API Report File for "scribing"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Equatable } from 'paratype';
import { JsonValue } from 'paratype';
import { RecordConstructor } from 'paratype';
import { RecordObject } from 'paratype';
import { Type } from 'paratype';

// @public
export interface ApplyMineOptions {
    // (undocumented)
    mergeUndo?: boolean;
}

// @public @sealed
export class DefaultFlowTheme extends DefaultFlowThemeBase {
    constructor();
    static readonly classType: Type<RecordObject<    {}, "default"> & Equatable & Readonly<{}> & DefaultFlowTheme>;
    getParagraphTheme(variant: ParagraphStyleVariant): ParagraphTheme;
    static get instance(): DefaultFlowTheme;
}

// @public
export const DefaultFlowThemeBase: RecordConstructor<    {}, FlowTheme, "default">;

// @public @sealed
export class DynamicText extends DynamicTextBase implements DynamicTextProps {
    static readonly classType: Type<DynamicText>;
    static fromData(data: DynamicTextData): DynamicText;
    readonly size = 1;
}

// @public
export const DynamicTextBase: RecordConstructor<DynamicTextProps, InlineNode, DynamicTextData>;

// @public
export interface DynamicTextData {
    dynamic: string;
    style?: TextStyle;
}

// @public
export interface DynamicTextProps {
    expression: string;
    style: TextStyle;
}

// @public @sealed
export class EditButton extends EditButtonBase implements EditButtonProps {
    static readonly classType: Type<EditButton>;
    createReplacementNode(content: FlowContent, before: FlowNode): FlowNode;
    static fromData(data: EditButtonData): EditButton;
    getInnerContentFromNode(node: FlowNode): FlowContent;
    mergeNext(next: FlowOperation): FlowOperation | null;
}

// @public
export const EditButtonBase: RecordConstructor<EditButtonProps, NestedFlowOperation, EditButtonData>;

// @public
export interface EditButtonData {
    at: number;
    edit: "button";
    op: FlowOperation;
}

// @public
export interface EditButtonProps {
    inner: FlowOperation;
    position: number;
}

// @public @sealed
export class FlowBatch extends FlowBatchBase implements Readonly<FlowBatchProps> {
    constructor(props?: FlowBatchProps);
    afterInsertion(other: FlowRange): FlowOperation | null;
    afterRemoval(other: FlowRange): FlowOperation | null;
    applyToContent(content: FlowContent, theme?: FlowTheme): FlowContent;
    // @override
    applyToSelection(selection: FlowSelection, mine: boolean): FlowSelection | null;
    static readonly classType: Type<FlowBatch>;
    static fromArray(operations: FlowOperation[]): FlowOperation | null;
    static fromData(data: FlowBatchData): FlowBatch;
    invert(content: FlowContent): FlowOperation | null;
    mergeNext(next: FlowOperation): FlowOperation | null;
    transform(other: FlowOperation): FlowOperation | null;
}

// @public
export const FlowBatchBase: RecordConstructor<FlowBatchProps, FlowOperation, FlowBatchData>;

// @public
export type FlowBatchData = readonly FlowOperation[];

// @public
export interface FlowBatchProps {
    operations: readonly FlowOperation[];
}

// @public @sealed
export class FlowButton extends FlowButtonBase {
    static readonly classType: Type<FlowButton>;
    formatParagraph(style: ParagraphStyle, theme?: FlowTheme): this;
    formatText(style: TextStyle, theme?: FlowTheme): this;
    static fromData(data: FlowButtonData): FlowButton;
    // @override
    getUniformParagraphStyle(theme?: ParagraphTheme, diff?: Set<keyof ParagraphStyleProps>): ParagraphStyle | null;
    // @override
    getUniformTextStyle(theme?: ParagraphTheme, diff?: Set<keyof TextStyleProps>): TextStyle;
    readonly size = 1;
    unformatAmbient(theme: ParagraphTheme): this;
    unformatParagraph(style: ParagraphStyle): this;
    unformatText(style: TextStyle): this;
}

// @public
export const FlowButtonBase: RecordConstructor<FlowButtonProps, FlowNode, FlowButtonData>;

// @public
export interface FlowButtonData {
    // (undocumented)
    action?: Interaction;
    // (undocumented)
    button: FlowContent;
}

// @public
export interface FlowButtonProps {
    // (undocumented)
    action: Interaction | null;
    // (undocumented)
    content: FlowContent;
}

// @public @sealed
export class FlowButtonSelection extends FlowButtonSelectionBase {
    static readonly classType: Type<FlowButtonSelection>;
    static fromData(data: FlowButtonSelectionData): FlowButtonSelection;
    // @override
    protected getInnerContentFromNode(node: FlowNode): FlowContent;
    // @override
    protected getInnerSelection(): FlowSelection;
    // @override
    protected getOuterOperation(inner: FlowOperation): FlowOperation;
    // @override
    protected setInnerSelection(value: FlowSelection): NestedFlowSelection;
}

// @public
export const FlowButtonSelectionBase: RecordConstructor<FlowButtonSelectionProps, NestedFlowSelection, FlowButtonSelectionData>;

// @public
export interface FlowButtonSelectionData {
    // (undocumented)
    button: number;
    // (undocumented)
    content: FlowSelection;
}

// @public
export interface FlowButtonSelectionProps {
    // (undocumented)
    content: FlowSelection;
    // (undocumented)
    position: number;
}

// @public @sealed
export class FlowContent extends FlowContentBase implements Readonly<FlowContentProps> {
    constructor(props?: FlowContentProps);
    append(...nodes: readonly FlowNode[]): FlowContent;
    append(theme: FlowTheme | undefined, ...nodes: readonly FlowNode[]): FlowContent;
    static readonly classType: Type<FlowContent>;
    copy(range: FlowRange): FlowContent;
    formatParagraph(range: FlowRange, style: ParagraphStyle, theme?: FlowTheme): FlowContent;
    formatText(range: FlowRange, style: TextStyle, theme?: FlowTheme): FlowContent;
    static fromData(data: FlowContentData): FlowContent;
    static fromJsonValue(value: JsonValue): FlowContent;
    incrementListLevel(range: FlowRange, delta: number, theme?: FlowTheme): FlowContent;
    insert(position: number, ...nodes: readonly FlowNode[]): FlowContent;
    insert(position: number, theme: FlowTheme | undefined, ...nodes: readonly FlowNode[]): FlowContent;
    peek(position?: number): FlowCursor;
    remove(range: FlowRange): FlowContent;
    replace(remove: FlowRange, ...insert: FlowNode[]): FlowContent;
    get size(): number;
    toJsonValue(): JsonValue;
    unformatAmbient(theme: FlowTheme): FlowContent;
    unformatParagraph(range: FlowRange, style: ParagraphStyle): FlowContent;
    unformatText(range: FlowRange, style: TextStyle): FlowContent;
}

// @public
export const FlowContentBase: RecordConstructor<FlowContentProps, Object, FlowContentData>;

// @public
export type FlowContentData = readonly FlowNode[];

// @public
export interface FlowContentProps {
    nodes: readonly FlowNode[];
}

// @public
export class FlowCursor {
    // @internal
    constructor(content: FlowContent);
    // @internal
    constructor(content: FlowContent, symbol: symbol, index: number, offset: number, position: number);
    get after(): Iterable<FlowNode>;
    get before(): Iterable<FlowNode>;
    findNodeForward(predicate: (node: FlowNode) => boolean): FlowCursor | null;
    getParagraphStyle(): ParagraphStyle | null;
    getTextStyle(): TextStyle | null;
    get index(): number;
    move(distance: number): FlowCursor;
    moveToStartOfNextNode(): FlowCursor | null;
    moveToStartOfNode(): FlowCursor;
    moveToStartOfPreviousNode(): FlowCursor | null;
    get node(): FlowNode | null;
    get offset(): number;
    get position(): number;
    range(distance: number): Iterable<FlowNode>;
}

// @public @sealed
export class FlowEditorState extends FlowEditorStateBase {
    applyMine(operation: FlowOperation, options?: ApplyMineOptions): FlowEditorState;
    applyTheirs(operation: FlowOperation): FlowEditorState;
    static readonly classType: Type<FlowEditorState>;
    static get empty(): FlowEditorState;
    static fromData(data: FlowEditorStateData): FlowEditorState;
    getUniformParagraphStyle(diff?: Set<keyof ParagraphStyleProps>): ParagraphStyle;
    getUniformTextStyle(diff?: Set<keyof TextStyleProps>): TextStyle;
    redo(): FlowEditorState;
    toggleFormattingMarks(): FlowEditorState;
    undo(): FlowEditorState;
}

// @public
export const FlowEditorStateBase: RecordConstructor<FlowEditorStateProps, Object, FlowEditorStateData>;

// @public
export interface FlowEditorStateData extends Partial<Omit<FlowEditorStateProps, "selection" | "undoStack" | "redoStack">> {
    // (undocumented)
    redo?: readonly FlowOperation[];
    // (undocumented)
    selection?: FlowSelection;
    // (undocumented)
    undo?: readonly FlowOperation[];
}

// @public
export interface FlowEditorStateProps {
    // (undocumented)
    caret: TextStyle;
    // (undocumented)
    content: FlowContent;
    // (undocumented)
    formattingMarks: boolean;
    // (undocumented)
    redoStack: readonly FlowOperation[];
    // (undocumented)
    selection: FlowSelection | null;
    // (undocumented)
    theme: FlowTheme;
    // (undocumented)
    undoStack: readonly FlowOperation[];
}

// @public
export abstract class FlowNode {
    static readonly baseType: Type<FlowNode>;
    abstract formatParagraph(style: ParagraphStyle, theme?: FlowTheme): FlowNode;
    abstract formatText(style: TextStyle, theme?: FlowTheme): FlowNode;
    static fromJsonValue(value: JsonValue): FlowNode;
    abstract getUniformParagraphStyle(theme?: ParagraphTheme, diff?: Set<keyof ParagraphStyleProps>): ParagraphStyle | null;
    abstract getUniformTextStyle(theme?: ParagraphTheme, diff?: Set<keyof TextStyleProps>): TextStyle | null;
    abstract readonly size: number;
    abstract toData(): unknown;
    toJsonValue(): JsonValue;
    abstract unformatAmbient(theme: ParagraphTheme): FlowNode;
    abstract unformatParagraph(style: ParagraphStyle): FlowNode;
    abstract unformatText(style: TextStyle): FlowNode;
}

// @public
export abstract class FlowOperation {
    // @internal
    abstract afterInsertion(other: FlowRange): FlowOperation | null;
    // @internal
    abstract afterRemoval(other: FlowRange): FlowOperation | null;
    abstract applyToContent(content: FlowContent, theme?: FlowTheme): FlowContent;
    abstract applyToSelection(selection: FlowSelection, mine: boolean): FlowSelection | null;
    static readonly baseType: Type<FlowOperation>;
    static fromJsonValue(value: JsonValue): FlowOperation;
    abstract invert(content: FlowContent): FlowOperation | null;
    abstract mergeNext(next: FlowOperation): FlowOperation | null;
    abstract toData(): unknown;
    toJsonValue(): JsonValue;
    abstract transform(other: FlowOperation): FlowOperation | null;
}

// @public @sealed
export class FlowRange extends FlowRangeBase implements Readonly<FlowRangeProps> {
    static at(position: number, distance?: number): FlowRange;
    static readonly classType: Type<FlowRange>;
    contains(position: number): boolean;
    deflate(delta: number): FlowRange;
    get distance(): number;
    get first(): number;
    static fromData(data: FlowRangeTuple): FlowRange;
    inflate(delta: number): FlowRange;
    intersect(other: FlowRange): FlowRange;
    get isBackward(): boolean;
    get isCollapsed(): boolean;
    get last(): number;
    reverse(): FlowRange;
    set(key: "first" | "last" | keyof FlowRangeProps, value: number): this;
    get size(): number;
    toString(): string;
    translate(delta: number): FlowRange;
}

// @public
export const FlowRangeBase: RecordConstructor<FlowRangeProps, Object, FlowRangeTuple>;

// @public
export interface FlowRangeProps {
    anchor: number;
    focus: number;
}

// @public @sealed
export class FlowRangeSelection extends FlowRangeSelectionBase implements Readonly<FlowRangeSelectionProps> {
    // @override
    afterInsertion(range: FlowRange, mine: boolean): FlowSelection | null;
    // @override
    afterRemoval(range: FlowRange, mine: boolean): FlowSelection | null;
    static readonly classType: Type<RecordObject<FlowRangeSelectionProps, FlowRangeSelectionProps> & Equatable & Readonly<FlowRangeSelectionProps> & FlowRangeSelection>;
    // @override
    formatParagraph(style: ParagraphStyle, options?: TargetOptions): FlowOperation | null;
    // @override
    formatText(style: TextStyle): FlowOperation | null;
    // @override
    getUniformParagraphStyle(content: FlowContent, theme?: FlowTheme, diff?: Set<keyof ParagraphStyleProps>): ParagraphStyle;
    // @override
    getUniformTextStyle(content: FlowContent, theme?: FlowTheme, diff?: Set<keyof TextStyleProps>): TextStyle;
    // @override
    incrementListLevel(content: FlowContent, delta?: number): FlowOperation | null;
    // @override
    insert(content: FlowContent, options?: TargetOptions): FlowOperation | null;
    // @override
    get isCollapsed(): boolean;
    // @override
    remove(options?: RemoveFlowSelectionOptions): FlowOperation | null;
    // @override
    transformRanges(transform: (range: FlowRange, options?: TargetOptions) => FlowRange | null, options?: TargetOptions): FlowSelection | null;
    // @override
    unformatParagraph(style: ParagraphStyle): FlowOperation | null;
    // @override
    unformatText(style: TextStyle): FlowOperation | null;
}

// @public
export const FlowRangeSelectionBase: RecordConstructor<FlowRangeSelectionProps, FlowSelection, FlowRangeSelectionProps>;

// @public
export interface FlowRangeSelectionProps {
    range: FlowRange;
}

// @public
export type FlowRangeTuple = [number, number];

// @public
export abstract class FlowSelection {
    // @internal
    abstract afterInsertion(range: FlowRange, mine: boolean): FlowSelection | null;
    // @internal
    abstract afterRemoval(range: FlowRange, mine: boolean): FlowSelection | null;
    static readonly baseType: Type<FlowSelection>;
    decrementListLevel(content: FlowContent, delta?: number): FlowOperation | null;
    abstract formatParagraph(style: ParagraphStyle, options?: TargetOptions): FlowOperation | null;
    abstract formatText(style: TextStyle, options?: TargetOptions): FlowOperation | null;
    static fromJsonValue(value: JsonValue): FlowSelection;
    abstract getUniformParagraphStyle(content: FlowContent, theme?: FlowTheme, diff?: Set<keyof ParagraphStyleProps>): ParagraphStyle;
    abstract getUniformTextStyle(content: FlowContent, theme?: FlowTheme, diff?: Set<keyof TextStyleProps>): TextStyle;
    abstract incrementListLevel(content: FlowContent, delta?: number): FlowOperation | null;
    abstract insert(content: FlowContent, options?: TargetOptions): FlowOperation | null;
    abstract get isCollapsed(): boolean;
    abstract remove(options?: RemoveFlowSelectionOptions): FlowOperation | null;
    toJsonValue(): JsonValue;
    abstract transformRanges(transform: (range: FlowRange, options?: TargetOptions) => FlowRange | null, options?: TargetOptions): FlowSelection | null;
    abstract unformatParagraph(style: ParagraphStyle): FlowOperation | null;
    abstract unformatText(style: TextStyle): FlowOperation | null;
}

// @public
export abstract class FlowTheme {
    static readonly baseType: Type<FlowTheme>;
    static fromJsonValue(value: JsonValue): FlowTheme;
    abstract getParagraphTheme(variant: ParagraphStyleVariant): ParagraphTheme;
    toJsonValue(): JsonValue;
}

// @public @sealed
export class FormatParagraph extends FormatParagraphBase implements Readonly<FormatParagraphProps> {
    afterInsertion(other: FlowRange): FlowOperation | null;
    afterRemoval(other: FlowRange): FlowOperation | null;
    // @override
    applyToContent(content: FlowContent, theme?: FlowTheme): FlowContent;
    // @override
    applyToSelection(selection: FlowSelection): FlowSelection;
    static readonly classType: Type<FormatParagraph>;
    static fromData(data: FormatParagraphData): FormatParagraph;
    // @override
    invert(content: FlowContent): FlowOperation | null;
    mergeNext(next: FlowOperation): FlowOperation | null;
    // @override
    transform(other: FlowOperation): FlowOperation | null;
}

// @public
export const FormatParagraphBase: RecordConstructor<FormatParagraphProps, FlowOperation, FormatParagraphData>;

// @public
export interface FormatParagraphData extends FormatParagraphProps {
    format: "para";
}

// @public
export interface FormatParagraphProps {
    range: FlowRange;
    style: ParagraphStyle;
}

// @public @sealed
export class FormatText extends FormatTextBase implements Readonly<FormatTextProps> {
    afterInsertion(other: FlowRange): FlowOperation | null;
    afterRemoval(other: FlowRange): FlowOperation | null;
    // @override
    applyToContent(content: FlowContent, theme?: FlowTheme): FlowContent;
    // @override
    applyToSelection(selection: FlowSelection): FlowSelection;
    static readonly classType: Type<FormatText>;
    static fromData(data: FormatTextData): FormatText;
    // @override
    invert(content: FlowContent): FlowOperation | null;
    mergeNext(next: FlowOperation): FlowOperation | null;
    // @override
    transform(other: FlowOperation): FlowOperation | null;
}

// @public
export const FormatTextBase: RecordConstructor<FormatTextProps, FlowOperation, FormatTextData>;

// @public
export interface FormatTextData extends FormatTextProps {
    format: "text";
}

// @public
export interface FormatTextProps {
    range: FlowRange;
    style: TextStyle;
}

// @public
export abstract class InlineNode extends FlowNode {
    formatParagraph(): this;
    formatText(style: TextStyle): this;
    // @override
    getUniformParagraphStyle(theme?: ParagraphTheme): ParagraphStyle | null;
    // @override
    getUniformTextStyle(theme?: ParagraphTheme): TextStyle;
    abstract set(key: "style", value: TextStyle): this;
    abstract readonly style: TextStyle;
    unformatAmbient(theme: ParagraphTheme): this;
    unformatParagraph(): this;
    unformatText(style: TextStyle): this;
}

// @public @sealed
export class InsertContent extends InsertContentBase implements InsertContentProps {
    afterInsertion(other: FlowRange): FlowOperation | null;
    afterRemoval(other: FlowRange): FlowOperation | null;
    applyToContent(content: FlowContent, theme?: FlowTheme): FlowContent;
    // @override
    applyToSelection(selection: FlowSelection, mine: boolean): FlowSelection | null;
    static readonly classType: Type<InsertContent>;
    static fromData(data: InsertContentData): InsertContent;
    invert(): FlowOperation | null;
    mergeNext(next: FlowOperation): FlowOperation | null;
    toData(): InsertContentData;
    transform(other: FlowOperation): FlowOperation | null;
    // @internal
    translate(delta: number): InsertContent;
}

// @public
export const InsertContentBase: RecordConstructor<InsertContentProps, FlowOperation, InsertContentData>;

// @public
export interface InsertContentData {
    at: number;
    insert: FlowContent;
}

// @public
export interface InsertContentProps {
    content: FlowContent;
    position: number;
}

// @public
export abstract class Interaction {
    static readonly baseType: Type<Interaction>;
    static fromJsonValue(value: JsonValue): Interaction;
    toJsonValue(): JsonValue;
}

// @public @sealed
export class LineBreak extends LineBreakBase implements LineBreakProps {
    constructor(props?: LineBreakProps);
    static readonly classType: Type<LineBreak>;
    static fromData(data: LineBreakData): LineBreak;
    readonly size = 1;
}

// @public
export const LineBreakBase: RecordConstructor<LineBreakProps, InlineNode, LineBreakData>;

// @public
export interface LineBreakData {
    break: "line";
    style?: TextStyle;
}

// @public
export interface LineBreakProps {
    style: TextStyle;
}

// @public
export const LIST_MARKER_KINDS: readonly ["unordered", "ordered", "disc", "circle", "square", "dash", "decimal", "lower-alpha", "upper-alpha", "lower-roman", "upper-roman"];

// @public
export type ListMarkerKind = (typeof LIST_MARKER_KINDS)[number];

// @public
export const ListMarkerKindType: Type<ListMarkerKind>;

// @public
export abstract class NestedFlowOperation extends FlowOperation {
    // @override
    afterInsertion(range: FlowRange): FlowOperation | null;
    // @override
    afterRemoval(range: FlowRange): FlowOperation | null;
    applyToContent(content: FlowContent, theme?: FlowTheme): FlowContent;
    // @override
    applyToSelection(selection: FlowSelection, mine: boolean): FlowSelection | null;
    protected abstract createReplacementNode(content: FlowContent, before: FlowNode): FlowNode;
    protected getInnerContent(outer: FlowContent): FlowContent;
    protected abstract getInnerContentFromNode(node: FlowNode): FlowContent;
    protected getTargetNode(outer: FlowContent): FlowNode;
    abstract inner: FlowOperation;
    invert(content: FlowContent): FlowOperation | null;
    abstract position: number;
    abstract set(key: "position", value: number): this;
    abstract set(key: "inner", value: FlowOperation): this;
    transform(other: FlowOperation): FlowOperation | null;
}

// @public
export abstract class NestedFlowSelection extends FlowSelection {
    // @override
    afterInsertion(range: FlowRange): FlowSelection | null;
    // @override
    afterRemoval(range: FlowRange, mine: boolean): FlowSelection | null;
    // @override
    formatParagraph(style: ParagraphStyle, options?: TargetOptions): FlowOperation | null;
    // @override
    formatText(style: TextStyle, options?: TargetOptions): FlowOperation | null;
    protected getInnerContent(outer: FlowContent): FlowContent;
    protected abstract getInnerContentFromNode(node: FlowNode): FlowContent;
    protected abstract getInnerSelection(): FlowSelection;
    protected abstract getOuterOperation(inner: FlowOperation): FlowOperation;
    protected getSelectedNode(outer: FlowContent): FlowNode;
    // @override
    getUniformParagraphStyle(content: FlowContent, theme?: FlowTheme, diff?: Set<keyof ParagraphStyleProps>): ParagraphStyle;
    // @override
    getUniformTextStyle(content: FlowContent, theme?: FlowTheme, diff?: Set<keyof TextStyleProps>): TextStyle;
    // @override
    incrementListLevel(content: FlowContent, delta?: number): FlowOperation | null;
    // @override
    insert(content: FlowContent, options?: TargetOptions): FlowOperation | null;
    // @override
    get isCollapsed(): boolean;
    abstract position: number;
    // @override
    remove(options?: RemoveFlowSelectionOptions): FlowOperation | null;
    abstract set(key: "position", value: number): this;
    protected abstract setInnerSelection(value: FlowSelection): NestedFlowSelection;
    // @override
    transformRanges(transform: (range: FlowRange, options?: TargetOptions) => FlowRange | null, options?: TargetOptions): FlowSelection | null;
    // @override
    unformatParagraph(style: ParagraphStyle): FlowOperation | null;
    // @override
    unformatText(style: TextStyle): FlowOperation | null;
    // @internal
    updateInner(callback: (inner: FlowSelection) => FlowSelection | null): FlowSelection | null;
}

// @public @sealed
export class OpenUrl extends OpenUrlBase {
    static readonly classType: Type<OpenUrl>;
    static fromData(data: string): OpenUrl;
}

// @public
export const OpenUrlBase: RecordConstructor<OpenUrlProps, Interaction, string>;

// @public
export interface OpenUrlProps {
    url: string;
}

// @public
export const PARAGRAPH_STYLE_VARIANTS: readonly ["normal", "h1", "h2", "h3", "h4", "h5", "h6", "title", "subtitle", "preamble", "code"];

// @public @sealed
export class ParagraphBreak extends ParagraphBreakBase implements ParagraphBreakProps {
    constructor(props?: ParagraphBreakProps);
    static readonly classType: Type<ParagraphBreak>;
    formatParagraph(style: ParagraphStyle): this;
    formatText(): this;
    static fromData(data: ParagraphBreakData): ParagraphBreak;
    // @override
    getUniformParagraphStyle(theme?: ParagraphTheme): ParagraphStyle | null;
    // @override
    getUniformTextStyle(theme?: ParagraphTheme): TextStyle;
    readonly size = 1;
    unformatAmbient(theme: ParagraphTheme): this;
    unformatParagraph(style: ParagraphStyle): this;
    unformatText(): this;
}

// @public
export const ParagraphBreakBase: RecordConstructor<ParagraphBreakProps, FlowNode, ParagraphBreakData>;

// @public
export interface ParagraphBreakData {
    break: "para";
    style?: ParagraphStyle;
}

// @public
export interface ParagraphBreakProps {
    style: ParagraphStyle;
}

// @public @sealed
export class ParagraphStyle extends ParagraphStyleBase implements Readonly<ParagraphStyleProps> {
    constructor(props?: ParagraphStyleProps);
    static readonly classType: Type<RecordObject<Partial<{
    alignment: "start" | "center" | "end" | "justify";
    direction: "ltr" | "rtl";
    variant: "normal" | "h1" | "h2" | "h3" | "h4" | "h5" | "h6" | "title" | "subtitle" | "preamble" | "code";
    lineSpacing: number;
    spaceAbove: number;
    spaceBelow: number;
    listLevel: number;
    listMarker: "unordered" | "ordered" | "disc" | "circle" | "square" | "dash" | "decimal" | "lower-alpha" | "upper-alpha" | "lower-roman" | "upper-roman";
    hideListMarker: boolean;
    listCounter: number | "auto" | "reset" | "resume";
    listCounterPrefix: string;
    listCounterSuffix: string;
    }>, Partial<{
    alignment: "start" | "center" | "end" | "justify";
    direction: "ltr" | "rtl";
    variant: "normal" | "h1" | "h2" | "h3" | "h4" | "h5" | "h6" | "title" | "subtitle" | "preamble" | "code";
    lineSpacing: number;
    spaceAbove: number;
    spaceBelow: number;
    listLevel: number;
    listMarker: "unordered" | "ordered" | "disc" | "circle" | "square" | "dash" | "decimal" | "lower-alpha" | "upper-alpha" | "lower-roman" | "upper-roman";
    hideListMarker: boolean;
    listCounter: number | "auto" | "reset" | "resume";
    listCounterPrefix: string;
    listCounterSuffix: string;
    }>> & Equatable & Readonly<Partial<{
        alignment: "start" | "center" | "end" | "justify";
        direction: "ltr" | "rtl";
        variant: "normal" | "h1" | "h2" | "h3" | "h4" | "h5" | "h6" | "title" | "subtitle" | "preamble" | "code";
        lineSpacing: number;
        spaceAbove: number;
        spaceBelow: number;
        listLevel: number;
        listMarker: "unordered" | "ordered" | "disc" | "circle" | "square" | "dash" | "decimal" | "lower-alpha" | "upper-alpha" | "lower-roman" | "upper-roman";
        hideListMarker: boolean;
        listCounter: number | "auto" | "reset" | "resume";
        listCounterPrefix: string;
        listCounterSuffix: string;
    }>> & ParagraphStyle>;
    static get empty(): ParagraphStyle;
    get isEmpty(): boolean;
}

// @public
export const ParagraphStyleBase: RecordConstructor<Partial<{
alignment: "start" | "center" | "end" | "justify";
direction: "ltr" | "rtl";
variant: "normal" | "h1" | "h2" | "h3" | "h4" | "h5" | "h6" | "title" | "subtitle" | "preamble" | "code";
lineSpacing: number;
spaceAbove: number;
spaceBelow: number;
listLevel: number;
listMarker: "unordered" | "ordered" | "disc" | "circle" | "square" | "dash" | "decimal" | "lower-alpha" | "upper-alpha" | "lower-roman" | "upper-roman";
hideListMarker: boolean;
listCounter: number | "auto" | "reset" | "resume";
listCounterPrefix: string;
listCounterSuffix: string;
}>, Object, Partial<{
alignment: "start" | "center" | "end" | "justify";
direction: "ltr" | "rtl";
variant: "normal" | "h1" | "h2" | "h3" | "h4" | "h5" | "h6" | "title" | "subtitle" | "preamble" | "code";
lineSpacing: number;
spaceAbove: number;
spaceBelow: number;
listLevel: number;
listMarker: "unordered" | "ordered" | "disc" | "circle" | "square" | "dash" | "decimal" | "lower-alpha" | "upper-alpha" | "lower-roman" | "upper-roman";
hideListMarker: boolean;
listCounter: number | "auto" | "reset" | "resume";
listCounterPrefix: string;
listCounterSuffix: string;
}>>;

// @public
export interface ParagraphStyleProps {
    alignment?: "start" | "center" | "end" | "justify";
    direction?: "ltr" | "rtl";
    hideListMarker?: boolean;
    lineSpacing?: number;
    listCounter?: number | "auto" | "reset" | "resume";
    listCounterPrefix?: string;
    listCounterSuffix?: string;
    listLevel?: number;
    listMarker?: ListMarkerKind;
    spaceAbove?: number;
    spaceBelow?: number;
    variant?: ParagraphStyleVariant;
}

// @public
export type ParagraphStyleVariant = (typeof PARAGRAPH_STYLE_VARIANTS)[number];

// @public
export const ParagraphStyleVariantType: Type<ParagraphStyleVariant>;

// @public
export abstract class ParagraphTheme {
    abstract getAmbientParagraphStyle(): ParagraphStyle;
    abstract getAmbientTextStyle(): TextStyle;
    abstract getFlowTheme(): FlowTheme;
    abstract getLinkStyle(): TextStyle;
    abstract getNextVariant(): ParagraphStyleVariant;
}

// @public
export interface RemoveFlowSelectionOptions extends TargetOptions {
    whenCollapsed?: "removeBackward" | "removeForward" | "noop";
}

// @public @sealed
export class RemoveRange extends RemoveRangeBase implements Readonly<RemoveRangeProps> {
    afterInsertion(other: FlowRange): FlowOperation | null;
    afterRemoval(other: FlowRange): FlowOperation | null;
    // @override
    applyToContent(content: FlowContent): FlowContent;
    // @override
    applyToSelection(selection: FlowSelection, mine: boolean): FlowSelection | null;
    static readonly classType: Type<RemoveRange>;
    static fromData(data: RemoveRangeData): RemoveRange;
    // @override
    invert(content: FlowContent): InsertContent;
    mergeNext(next: FlowOperation): FlowOperation | null;
    // @override
    transform(other: FlowOperation): FlowOperation | null;
}

// @public
export const RemoveRangeBase: RecordConstructor<RemoveRangeProps, FlowOperation, RemoveRangeData>;

// @public
export interface RemoveRangeData {
    remove: FlowRange;
}

// @public
export interface RemoveRangeProps {
    range: FlowRange;
}

// @public @sealed
export class RunScript extends RunScriptBase {
    static readonly classType: Type<RecordObject<RunScriptProps, RunScriptProps> & Equatable & Readonly<RunScriptProps> & RunScript>;
}

// @public
export const RunScriptBase: RecordConstructor<RunScriptProps, Interaction, RunScriptProps>;

// @public
export interface RunScriptProps {
    script: string;
}

// @public @sealed
export class SetButtonAction extends SetButtonActionBase implements SetButtonActionProps {
    afterInsertion(range: FlowRange): FlowOperation | null;
    afterRemoval(range: FlowRange): FlowOperation | null;
    // @override
    applyToContent(content: FlowContent): FlowContent;
    // @override
    applyToSelection(selection: FlowSelection): FlowSelection;
    static readonly classType: Type<SetButtonAction>;
    static fromData(data: SetButtonActionData): SetButtonAction;
    // @override
    invert(content: FlowContent): FlowOperation | null;
    mergeNext(next: FlowOperation): FlowOperation | null;
    // @override
    transform(other: FlowOperation): FlowOperation | null;
}

// @public
export const SetButtonActionBase: RecordConstructor<SetButtonActionProps, FlowOperation, SetButtonActionData>;

// @public
export interface SetButtonActionData {
    at: number;
    set: "button_action";
    value: Interaction | null;
}

// @public
export interface SetButtonActionProps {
    action: Interaction | null;
    position: number;
}

// @public @sealed
export class SetDynamicTextExpression extends SetDynamicTextExpressionBase implements SetDynamicTextExpressionProps {
    afterInsertion(range: FlowRange): FlowOperation | null;
    afterRemoval(range: FlowRange): FlowOperation | null;
    // @override
    applyToContent(content: FlowContent): FlowContent;
    // @override
    applyToSelection(selection: FlowSelection): FlowSelection;
    static readonly classType: Type<SetDynamicTextExpression>;
    static fromData(data: SetDynamicTextExpressionData): SetDynamicTextExpression;
    // @override
    invert(content: FlowContent): FlowOperation | null;
    mergeNext(next: FlowOperation): FlowOperation | null;
    // @override
    transform(other: FlowOperation): FlowOperation | null;
}

// @public
export const SetDynamicTextExpressionBase: RecordConstructor<SetDynamicTextExpressionProps, FlowOperation, SetDynamicTextExpressionData>;

// @public
export interface SetDynamicTextExpressionData {
    at: number;
    set: "dynamic_text_expression";
    value: string;
}

// @public
export interface SetDynamicTextExpressionProps {
    expression: string;
    position: number;
}

// @public
export interface TargetOptions {
    target?: FlowContent;
    theme?: FlowTheme;
}

// @public
export const TEXT_COLORS: readonly ["default", "subtle", "primary", "secondary", "information", "success", "warning", "error"];

// @public
export type TextColor = (typeof TEXT_COLORS)[number];

// @public
export const TextColorType: Type<TextColor>;

// @public @sealed
export class TextRun extends TextRunBase implements Readonly<TextRunProps> {
    constructor(props?: TextRunProps);
    after(position: number): TextRun;
    append(value: string): TextRun;
    before(position: number): TextRun;
    static readonly classType: Type<TextRun>;
    static fromData(data: TextRunData): TextRun;
    // @internal
    static merge(first: TextRun, second: TextRun): TextRun;
    static normalizeText(value: unknown): string;
    // @internal
    static shouldMerge(first: TextRun, second: TextRun): boolean;
    readonly size: number;
    split(position: number): [TextRun, TextRun];
}

// @public
export const TextRunBase: RecordConstructor<TextRunProps, InlineNode, TextRunData>;

// @public
export type TextRunData = string | (Pick<TextRunProps, "text"> & Partial<Omit<TextRunProps, "text">>);

// @public
export interface TextRunProps {
    style: TextStyle;
    text: string;
}

// @public @sealed
export class TextStyle extends TextStyleBase implements Readonly<TextStyleProps> {
    constructor(props?: TextStyleProps);
    static readonly classType: Type<RecordObject<Partial<{
    bold: boolean;
    italic: boolean;
    underline: boolean;
    strike: boolean;
    baseline: "normal" | "sub" | "super";
    fontFamily: "body" | "heading" | "monospace";
    fontSize: number;
    link: Interaction | null;
    color: "default" | "subtle" | "primary" | "secondary" | "information" | "success" | "warning" | "error";
    }>, Partial<{
    bold: boolean;
    italic: boolean;
    underline: boolean;
    strike: boolean;
    baseline: "normal" | "sub" | "super";
    fontFamily: "body" | "heading" | "monospace";
    fontSize: number;
    link: Interaction | null;
    color: "default" | "subtle" | "primary" | "secondary" | "information" | "success" | "warning" | "error";
    }>> & Equatable & Readonly<Partial<{
        bold: boolean;
        italic: boolean;
        underline: boolean;
        strike: boolean;
        baseline: "normal" | "sub" | "super";
        fontFamily: "body" | "heading" | "monospace";
        fontSize: number;
        link: Interaction | null;
        color: "default" | "subtle" | "primary" | "secondary" | "information" | "success" | "warning" | "error";
    }>> & TextStyle>;
    static get empty(): TextStyle;
    get isEmpty(): boolean;
}

// @public
export const TextStyleBase: RecordConstructor<Partial<{
bold: boolean;
italic: boolean;
underline: boolean;
strike: boolean;
baseline: "normal" | "sub" | "super";
fontFamily: "body" | "heading" | "monospace";
fontSize: number;
link: Interaction | null;
color: "default" | "subtle" | "primary" | "secondary" | "information" | "success" | "warning" | "error";
}>, Object, Partial<{
bold: boolean;
italic: boolean;
underline: boolean;
strike: boolean;
baseline: "normal" | "sub" | "super";
fontFamily: "body" | "heading" | "monospace";
fontSize: number;
link: Interaction | null;
color: "default" | "subtle" | "primary" | "secondary" | "information" | "success" | "warning" | "error";
}>>;

// @public
export interface TextStyleProps {
    baseline?: "normal" | "sub" | "super";
    bold?: boolean;
    color?: TextColor;
    fontFamily?: "body" | "heading" | "monospace";
    fontSize?: number;
    italic?: boolean;
    link?: Interaction | null;
    strike?: boolean;
    underline?: boolean;
}

// @public @sealed
export class UnformatParagraph extends UnformatParagraphBase implements Readonly<UnformatParagraphProps> {
    afterInsertion(other: FlowRange): FlowOperation | null;
    afterRemoval(other: FlowRange): FlowOperation | null;
    // @override
    applyToContent(content: FlowContent): FlowContent;
    // @override
    applyToSelection(selection: FlowSelection): FlowSelection;
    static readonly classType: Type<UnformatParagraph>;
    static fromData(data: UnformatParagraphData): UnformatParagraph;
    // @override
    invert(content: FlowContent): FlowOperation | null;
    mergeNext(next: FlowOperation): FlowOperation | null;
    // @override
    transform(other: FlowOperation): FlowOperation | null;
}

// @public
export const UnformatParagraphBase: RecordConstructor<UnformatParagraphProps, FlowOperation, UnformatParagraphData>;

// @public
export interface UnformatParagraphData extends UnformatParagraphProps {
    unformat: "para";
}

// @public
export interface UnformatParagraphProps {
    range: FlowRange;
    style: ParagraphStyle;
}

// @public @sealed
export class UnformatText extends UnformatTextBase implements Readonly<UnformatTextProps> {
    afterInsertion(other: FlowRange): FlowOperation | null;
    afterRemoval(other: FlowRange): FlowOperation | null;
    // @override
    applyToContent(content: FlowContent): FlowContent;
    // @override
    applyToSelection(selection: FlowSelection): FlowSelection;
    static readonly classType: Type<UnformatText>;
    static fromData(data: UnformatTextData): UnformatText;
    // @override
    invert(content: FlowContent): FlowOperation | null;
    mergeNext(next: FlowOperation): FlowOperation | null;
    // @override
    transform(other: FlowOperation): FlowOperation | null;
}

// @public
export const UnformatTextBase: RecordConstructor<UnformatTextProps, FlowOperation, UnformatTextData>;

// @public
export interface UnformatTextData extends UnformatTextProps {
    unformat: "text";
}

// @public
export interface UnformatTextProps {
    range: FlowRange;
    style: TextStyle;
}

```
