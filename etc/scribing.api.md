## API Report File for "scribing"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Equatable } from 'paratype';
import { JsonValue } from 'paratype';
import { RecordConstructor } from 'paratype';
import { RecordObject } from 'paratype';
import { Type } from 'paratype';

// @public
export interface ApplyMineOptions {
    // (undocumented)
    mergeUndo?: boolean;
}

// @public
export const BOX_VARIANTS: readonly ["basic", "contained", "outlined", "alert", "quote"];

// @public @sealed
export class BoxStyle extends BoxStyleBase implements Readonly<BoxStyleProps> {
    constructor(props?: BoxStyleProps);
    static readonly classType: Type<RecordObject<Partial<{
    variant: "basic" | "contained" | "outlined" | "alert" | "quote";
    color: "default" | "subtle" | "primary" | "secondary" | "information" | "success" | "warning" | "error";
    inline: boolean;
    condition: string | null;
    interaction: Interaction | null;
    }>, Partial<{
    variant: "basic" | "contained" | "outlined" | "alert" | "quote";
    color: "default" | "subtle" | "primary" | "secondary" | "information" | "success" | "warning" | "error";
    inline: boolean;
    condition: string | null;
    interaction: Interaction | null;
    }>> & Equatable & Readonly<Partial<{
        variant: "basic" | "contained" | "outlined" | "alert" | "quote";
        color: "default" | "subtle" | "primary" | "secondary" | "information" | "success" | "warning" | "error";
        inline: boolean;
        condition: string | null;
        interaction: Interaction | null;
    }>> & BoxStyle>;
    static get empty(): BoxStyle;
    get isEmpty(): boolean;
}

// @public
export const BoxStyleBase: RecordConstructor<Partial<{
variant: "basic" | "contained" | "outlined" | "alert" | "quote";
color: "default" | "subtle" | "primary" | "secondary" | "information" | "success" | "warning" | "error";
inline: boolean;
condition: string | null;
interaction: Interaction | null;
}>, Object, Partial<{
variant: "basic" | "contained" | "outlined" | "alert" | "quote";
color: "default" | "subtle" | "primary" | "secondary" | "information" | "success" | "warning" | "error";
inline: boolean;
condition: string | null;
interaction: Interaction | null;
}>>;

// @public
export interface BoxStyleProps {
    color?: FlowColor;
    condition?: string | null;
    inline?: boolean;
    interaction?: Interaction | null;
    variant?: BoxVariant;
}

// @public
export type BoxVariant = (typeof BOX_VARIANTS)[number];

// @public
export const BoxVariantType: Type<BoxVariant>;

// @public @sealed
export class DefaultFlowTheme extends DefaultFlowThemeBase {
    constructor();
    static readonly classType: Type<RecordObject<    {}, "default"> & Equatable & Readonly<{}> & DefaultFlowTheme>;
    getParagraphTheme(variant: ParagraphVariant): ParagraphTheme;
    static get instance(): DefaultFlowTheme;
}

// @public
export const DefaultFlowThemeBase: RecordConstructor<    {}, FlowTheme, "default">;

// @public @sealed
export class DynamicText extends DynamicTextBase implements DynamicTextProps {
    static readonly classType: Type<DynamicText>;
    static fromData(data: DynamicTextData): DynamicText;
    readonly size = 1;
}

// @public
export const DynamicTextBase: RecordConstructor<DynamicTextProps, InlineNode, DynamicTextData>;

// @public
export interface DynamicTextData {
    dynamic: string;
    style?: TextStyle;
}

// @public
export interface DynamicTextProps {
    expression: string;
    style: TextStyle;
}

// @public @sealed
export class EditBox extends EditBoxBase implements EditBoxProps {
    static readonly classType: Type<EditBox>;
    createReplacementNode(content: FlowContent, before: FlowNode): FlowNode;
    static fromData(data: EditBoxData): EditBox;
    getInnerContentFromNode(node: FlowNode): FlowContent;
    mergeNext(next: FlowOperation): FlowOperation | null;
}

// @public
export const EditBoxBase: RecordConstructor<EditBoxProps, NestedFlowOperation, EditBoxData>;

// @public
export interface EditBoxData {
    at: number;
    edit: "box";
    op: FlowOperation;
}

// @public
export interface EditBoxProps {
    inner: FlowOperation;
    position: number;
}

// @public
export const FLOW_COLORS: readonly ["default", "subtle", "primary", "secondary", "information", "success", "warning", "error"];

// @public @sealed
export class FlowBatch extends FlowBatchBase implements Readonly<FlowBatchProps> {
    constructor(props?: FlowBatchProps);
    afterInsertion(other: FlowRange): FlowOperation | null;
    afterRemoval(other: FlowRange): FlowOperation | null;
    applyToContent(content: FlowContent, theme?: FlowTheme): FlowContent;
    // @override
    applyToSelection(selection: FlowSelection, mine: boolean): FlowSelection | null;
    static readonly classType: Type<FlowBatch>;
    static fromArray(operations: FlowOperation[]): FlowOperation | null;
    static fromData(data: FlowBatchData): FlowBatch;
    invert(content: FlowContent): FlowOperation | null;
    mergeNext(next: FlowOperation): FlowOperation | null;
    transform(other: FlowOperation): FlowOperation | null;
}

// @public
export const FlowBatchBase: RecordConstructor<FlowBatchProps, FlowOperation, FlowBatchData>;

// @public
export type FlowBatchData = readonly FlowOperation[];

// @public
export interface FlowBatchProps {
    operations: readonly FlowOperation[];
}

// @public @sealed
export class FlowBox extends FlowBoxBase {
    static readonly classType: Type<FlowBox>;
    formatBox(style: BoxStyle): this;
    formatParagraph(style: ParagraphStyle, theme?: FlowTheme): this;
    formatText(style: TextStyle, theme?: FlowTheme): this;
    static fromData(data: FlowBoxData): FlowBox;
    // @override
    getUniformParagraphStyle(theme?: ParagraphTheme, diff?: Set<keyof ParagraphStyleProps>): ParagraphStyle | null;
    // @override
    getUniformTextStyle(theme?: ParagraphTheme, diff?: Set<keyof TextStyleProps>): TextStyle;
    readonly size = 1;
    unformatAmbient(theme: ParagraphTheme): this;
    unformatBox(style: BoxStyle): this;
    unformatParagraph(style: ParagraphStyle): this;
    unformatText(style: TextStyle): this;
}

// @public
export const FlowBoxBase: RecordConstructor<FlowBoxProps, FlowNode, FlowBoxData>;

// @public
export interface FlowBoxData {
    // (undocumented)
    box: FlowContent;
    // (undocumented)
    style?: BoxStyle;
}

// @public
export interface FlowBoxProps {
    // (undocumented)
    content: FlowContent;
    // (undocumented)
    style: BoxStyle;
}

// @public @sealed
export class FlowBoxSelection extends FlowBoxSelectionBase {
    static readonly classType: Type<FlowBoxSelection>;
    static fromData(data: FlowBoxSelectionData): FlowBoxSelection;
    // @override
    protected getInnerContentFromNode(node: FlowNode): FlowContent;
    // @override
    protected getInnerSelection(): FlowSelection;
    // @override
    protected getOuterOperation(inner: FlowOperation): FlowOperation;
    // @override
    protected setInnerSelection(value: FlowSelection): NestedFlowSelection;
}

// @public
export const FlowBoxSelectionBase: RecordConstructor<FlowBoxSelectionProps, NestedFlowSelection, FlowBoxSelectionData>;

// @public
export interface FlowBoxSelectionData {
    // (undocumented)
    box: number;
    // (undocumented)
    content: FlowSelection;
}

// @public
export interface FlowBoxSelectionProps {
    // (undocumented)
    content: FlowSelection;
    // (undocumented)
    position: number;
}

// @public
export type FlowColor = (typeof FLOW_COLORS)[number];

// @public
export const FlowColorType: Type<FlowColor>;

// @public @sealed
export class FlowContent extends FlowContentBase implements Readonly<FlowContentProps> {
    constructor(props?: FlowContentProps);
    append(...nodes: readonly FlowNode[]): FlowContent;
    append(theme: FlowTheme | undefined, ...nodes: readonly FlowNode[]): FlowContent;
    static readonly classType: Type<FlowContent>;
    copy(range: FlowRange): FlowContent;
    formatBox(range: FlowRange, style: BoxStyle, theme?: FlowTheme): FlowContent;
    formatParagraph(range: FlowRange, style: ParagraphStyle, theme?: FlowTheme): FlowContent;
    formatText(range: FlowRange, style: TextStyle, theme?: FlowTheme): FlowContent;
    static fromData(data: FlowContentData): FlowContent;
    static fromJsonValue(value: JsonValue): FlowContent;
    incrementListLevel(range: FlowRange, delta: number, theme?: FlowTheme): FlowContent;
    insert(position: number, ...nodes: readonly FlowNode[]): FlowContent;
    insert(position: number, theme: FlowTheme | undefined, ...nodes: readonly FlowNode[]): FlowContent;
    peek(position?: number): FlowCursor;
    remove(range: FlowRange): FlowContent;
    replace(remove: FlowRange, ...insert: FlowNode[]): FlowContent;
    get size(): number;
    toJsonValue(): JsonValue;
    unformatAmbient(theme: FlowTheme): FlowContent;
    unformatBox(range: FlowRange, style: BoxStyle): FlowContent;
    unformatParagraph(range: FlowRange, style: ParagraphStyle): FlowContent;
    unformatText(range: FlowRange, style: TextStyle): FlowContent;
}

// @public
export const FlowContentBase: RecordConstructor<FlowContentProps, Object, FlowContentData>;

// @public
export type FlowContentData = readonly FlowNode[];

// @public
export interface FlowContentProps {
    nodes: readonly FlowNode[];
}

// @public
export class FlowCursor {
    // @internal
    constructor(content: FlowContent);
    // @internal
    constructor(content: FlowContent, symbol: symbol, index: number, offset: number, position: number);
    get after(): Iterable<FlowNode>;
    get before(): Iterable<FlowNode>;
    findNodeForward(predicate: (node: FlowNode) => boolean): FlowCursor | null;
    getParagraphStyle(): ParagraphStyle | null;
    getTextStyle(): TextStyle | null;
    get index(): number;
    move(distance: number): FlowCursor;
    moveToStartOfNextNode(): FlowCursor | null;
    moveToStartOfNode(): FlowCursor;
    moveToStartOfPreviousNode(): FlowCursor | null;
    get node(): FlowNode | null;
    get offset(): number;
    get position(): number;
    range(distance: number): Iterable<FlowNode>;
}

// @public @sealed
export class FlowEditorState extends FlowEditorStateBase {
    applyMine(operation: FlowOperation, options?: ApplyMineOptions): FlowEditorState;
    applyTheirs(operation: FlowOperation): FlowEditorState;
    static readonly classType: Type<FlowEditorState>;
    static get empty(): FlowEditorState;
    static fromData(data: FlowEditorStateData): FlowEditorState;
    getUniformParagraphStyle(diff?: Set<keyof ParagraphStyleProps>): ParagraphStyle;
    getUniformTextStyle(diff?: Set<keyof TextStyleProps>): TextStyle;
    redo(): FlowEditorState;
    toggleFormattingMarks(): FlowEditorState;
    undo(): FlowEditorState;
}

// @public
export const FlowEditorStateBase: RecordConstructor<FlowEditorStateProps, Object, FlowEditorStateData>;

// @public
export interface FlowEditorStateData extends Partial<Omit<FlowEditorStateProps, "selection" | "undoStack" | "redoStack">> {
    // (undocumented)
    redo?: readonly FlowOperation[];
    // (undocumented)
    selection?: FlowSelection;
    // (undocumented)
    undo?: readonly FlowOperation[];
}

// @public
export interface FlowEditorStateProps {
    // (undocumented)
    caret: TextStyle;
    // (undocumented)
    content: FlowContent;
    // (undocumented)
    formattingMarks: boolean;
    // (undocumented)
    redoStack: readonly FlowOperation[];
    // (undocumented)
    selection: FlowSelection | null;
    // (undocumented)
    theme: FlowTheme;
    // (undocumented)
    undoStack: readonly FlowOperation[];
}

// @public
export abstract class FlowNode {
    static readonly baseType: Type<FlowNode>;
    abstract formatBox(style: BoxStyle, theme?: FlowTheme): FlowNode;
    abstract formatParagraph(style: ParagraphStyle, theme?: FlowTheme): FlowNode;
    abstract formatText(style: TextStyle, theme?: FlowTheme): FlowNode;
    static fromJsonValue(value: JsonValue): FlowNode;
    abstract getUniformParagraphStyle(theme?: ParagraphTheme, diff?: Set<keyof ParagraphStyleProps>): ParagraphStyle | null;
    abstract getUniformTextStyle(theme?: ParagraphTheme, diff?: Set<keyof TextStyleProps>): TextStyle | null;
    abstract readonly size: number;
    abstract toData(): unknown;
    toJsonValue(): JsonValue;
    abstract unformatAmbient(theme: ParagraphTheme): FlowNode;
    abstract unformatBox(style: BoxStyle): FlowNode;
    abstract unformatParagraph(style: ParagraphStyle): FlowNode;
    abstract unformatText(style: TextStyle): FlowNode;
}

// @public
export abstract class FlowOperation {
    // @internal
    abstract afterInsertion(other: FlowRange): FlowOperation | null;
    // @internal
    abstract afterRemoval(other: FlowRange): FlowOperation | null;
    abstract applyToContent(content: FlowContent, theme?: FlowTheme): FlowContent;
    abstract applyToSelection(selection: FlowSelection, mine: boolean): FlowSelection | null;
    static readonly baseType: Type<FlowOperation>;
    static fromJsonValue(value: JsonValue): FlowOperation;
    abstract invert(content: FlowContent): FlowOperation | null;
    abstract mergeNext(next: FlowOperation): FlowOperation | null;
    abstract toData(): unknown;
    toJsonValue(): JsonValue;
    abstract transform(other: FlowOperation): FlowOperation | null;
}

// @public @sealed
export class FlowRange extends FlowRangeBase implements Readonly<FlowRangeProps> {
    static at(position: number, distance?: number): FlowRange;
    static readonly classType: Type<FlowRange>;
    contains(position: number): boolean;
    deflate(delta: number): FlowRange;
    get distance(): number;
    get first(): number;
    static fromData(data: FlowRangeTuple): FlowRange;
    inflate(delta: number): FlowRange;
    intersect(other: FlowRange): FlowRange;
    get isBackward(): boolean;
    get isCollapsed(): boolean;
    get last(): number;
    reverse(): FlowRange;
    set(key: "first" | "last" | keyof FlowRangeProps, value: number): this;
    get size(): number;
    toString(): string;
    translate(delta: number): FlowRange;
}

// @public
export const FlowRangeBase: RecordConstructor<FlowRangeProps, Object, FlowRangeTuple>;

// @public
export interface FlowRangeProps {
    anchor: number;
    focus: number;
}

// @public @sealed
export class FlowRangeSelection extends FlowRangeSelectionBase implements Readonly<FlowRangeSelectionProps> {
    // @override
    afterInsertion(range: FlowRange, mine: boolean): FlowSelection | null;
    // @override
    afterRemoval(range: FlowRange, mine: boolean): FlowSelection | null;
    static readonly classType: Type<RecordObject<FlowRangeSelectionProps, FlowRangeSelectionProps> & Equatable & Readonly<FlowRangeSelectionProps> & FlowRangeSelection>;
    // @override
    formatBox(style: BoxStyle): FlowOperation | null;
    // @override
    formatList(content: FlowContent, kind: "ordered" | "unordered" | null): FlowOperation | null;
    // @override
    formatParagraph(style: ParagraphStyle, options?: TargetOptions): FlowOperation | null;
    // @override
    formatText(style: TextStyle): FlowOperation | null;
    // @override
    getUniformParagraphStyle(content: FlowContent, theme?: FlowTheme, diff?: Set<keyof ParagraphStyleProps>): ParagraphStyle;
    // @override
    getUniformTextStyle(content: FlowContent, theme?: FlowTheme, diff?: Set<keyof TextStyleProps>): TextStyle;
    // @override
    incrementListLevel(content: FlowContent, delta?: number): FlowOperation | null;
    // @override
    insert(content: FlowContent, options?: TargetOptions): FlowOperation | null;
    // @override
    get isCollapsed(): boolean;
    // @override
    remove(options?: RemoveFlowSelectionOptions): FlowOperation | null;
    // @override
    transformRanges(transform: (range: FlowRange, options?: TargetOptions) => FlowRange | null, options?: TargetOptions): FlowSelection | null;
    // @override
    unformatBox(style: BoxStyle): FlowOperation | null;
    // @override
    unformatParagraph(style: ParagraphStyle): FlowOperation | null;
    // @override
    unformatText(style: TextStyle): FlowOperation | null;
}

// @public
export const FlowRangeSelectionBase: RecordConstructor<FlowRangeSelectionProps, FlowSelection, FlowRangeSelectionProps>;

// @public
export interface FlowRangeSelectionProps {
    range: FlowRange;
}

// @public
export type FlowRangeTuple = [number, number];

// @public
export abstract class FlowSelection {
    // @internal
    abstract afterInsertion(range: FlowRange, mine: boolean): FlowSelection | null;
    // @internal
    abstract afterRemoval(range: FlowRange, mine: boolean): FlowSelection | null;
    static readonly baseType: Type<FlowSelection>;
    decrementListLevel(content: FlowContent, delta?: number): FlowOperation | null;
    abstract formatBox(style: BoxStyle, options?: TargetOptions): FlowOperation | null;
    abstract formatList(content: FlowContent, kind: "ordered" | "unordered" | null): FlowOperation | null;
    abstract formatParagraph(style: ParagraphStyle, options?: TargetOptions): FlowOperation | null;
    abstract formatText(style: TextStyle, options?: TargetOptions): FlowOperation | null;
    static fromJsonValue(value: JsonValue): FlowSelection;
    abstract getUniformParagraphStyle(content: FlowContent, theme?: FlowTheme, diff?: Set<keyof ParagraphStyleProps>): ParagraphStyle;
    abstract getUniformTextStyle(content: FlowContent, theme?: FlowTheme, diff?: Set<keyof TextStyleProps>): TextStyle;
    abstract incrementListLevel(content: FlowContent, delta?: number): FlowOperation | null;
    abstract insert(content: FlowContent, options?: TargetOptions): FlowOperation | null;
    abstract get isCollapsed(): boolean;
    abstract remove(options?: RemoveFlowSelectionOptions): FlowOperation | null;
    toJsonValue(): JsonValue;
    abstract transformRanges(transform: (range: FlowRange, options?: TargetOptions) => FlowRange | null, options?: TargetOptions): FlowSelection | null;
    abstract unformatBox(style: BoxStyle): FlowOperation | null;
    abstract unformatParagraph(style: ParagraphStyle): FlowOperation | null;
    abstract unformatText(style: TextStyle): FlowOperation | null;
}

// @public
export abstract class FlowTheme {
    static readonly baseType: Type<FlowTheme>;
    static fromJsonValue(value: JsonValue): FlowTheme;
    abstract getParagraphTheme(variant: ParagraphVariant): ParagraphTheme;
    toJsonValue(): JsonValue;
}

// @public @sealed
export class FormatBox extends FormatBoxBase implements Readonly<FormatBoxProps> {
    afterInsertion(other: FlowRange): FlowOperation | null;
    afterRemoval(other: FlowRange): FlowOperation | null;
    // @override
    applyToContent(content: FlowContent, theme?: FlowTheme): FlowContent;
    // @override
    applyToSelection(selection: FlowSelection): FlowSelection;
    static readonly classType: Type<FormatBox>;
    static fromData(data: FormatBoxData): FormatBox;
    // @override
    invert(content: FlowContent): FlowOperation | null;
    mergeNext(next: FlowOperation): FlowOperation | null;
    // @override
    transform(other: FlowOperation): FlowOperation | null;
}

// @public
export const FormatBoxBase: RecordConstructor<FormatBoxProps, FlowOperation, FormatBoxData>;

// @public
export interface FormatBoxData extends FormatBoxProps {
    format: "box";
}

// @public
export interface FormatBoxProps {
    range: FlowRange;
    style: BoxStyle;
}

// @public @sealed
export class FormatParagraph extends FormatParagraphBase implements Readonly<FormatParagraphProps> {
    afterInsertion(other: FlowRange): FlowOperation | null;
    afterRemoval(other: FlowRange): FlowOperation | null;
    // @override
    applyToContent(content: FlowContent, theme?: FlowTheme): FlowContent;
    // @override
    applyToSelection(selection: FlowSelection): FlowSelection;
    static readonly classType: Type<FormatParagraph>;
    static fromData(data: FormatParagraphData): FormatParagraph;
    // @override
    invert(content: FlowContent): FlowOperation | null;
    mergeNext(next: FlowOperation): FlowOperation | null;
    // @override
    transform(other: FlowOperation): FlowOperation | null;
}

// @public
export const FormatParagraphBase: RecordConstructor<FormatParagraphProps, FlowOperation, FormatParagraphData>;

// @public
export interface FormatParagraphData extends FormatParagraphProps {
    format: "para";
}

// @public
export interface FormatParagraphProps {
    range: FlowRange;
    style: ParagraphStyle;
}

// @public @sealed
export class FormatText extends FormatTextBase implements Readonly<FormatTextProps> {
    afterInsertion(other: FlowRange): FlowOperation | null;
    afterRemoval(other: FlowRange): FlowOperation | null;
    // @override
    applyToContent(content: FlowContent, theme?: FlowTheme): FlowContent;
    // @override
    applyToSelection(selection: FlowSelection): FlowSelection;
    static readonly classType: Type<FormatText>;
    static fromData(data: FormatTextData): FormatText;
    // @override
    invert(content: FlowContent): FlowOperation | null;
    mergeNext(next: FlowOperation): FlowOperation | null;
    // @override
    transform(other: FlowOperation): FlowOperation | null;
}

// @public
export const FormatTextBase: RecordConstructor<FormatTextProps, FlowOperation, FormatTextData>;

// @public
export interface FormatTextData extends FormatTextProps {
    format: "text";
}

// @public
export interface FormatTextProps {
    range: FlowRange;
    style: TextStyle;
}

// @public
export abstract class InlineNode extends FlowNode {
    formatBox(): this;
    formatParagraph(): this;
    formatText(style: TextStyle): this;
    // @override
    getUniformParagraphStyle(): ParagraphStyle | null;
    // @override
    getUniformTextStyle(theme?: ParagraphTheme): TextStyle;
    abstract set(key: "style", value: TextStyle): this;
    abstract readonly style: TextStyle;
    unformatAmbient(theme: ParagraphTheme): this;
    unformatBox(): this;
    unformatParagraph(): this;
    unformatText(style: TextStyle): this;
}

// @public @sealed
export class InsertContent extends InsertContentBase implements InsertContentProps {
    afterInsertion(other: FlowRange): FlowOperation | null;
    afterRemoval(other: FlowRange): FlowOperation | null;
    applyToContent(content: FlowContent, theme?: FlowTheme): FlowContent;
    // @override
    applyToSelection(selection: FlowSelection, mine: boolean): FlowSelection | null;
    static readonly classType: Type<InsertContent>;
    static fromData(data: InsertContentData): InsertContent;
    invert(): FlowOperation | null;
    mergeNext(next: FlowOperation): FlowOperation | null;
    toData(): InsertContentData;
    transform(other: FlowOperation): FlowOperation | null;
    // @internal
    translate(delta: number): InsertContent;
}

// @public
export const InsertContentBase: RecordConstructor<InsertContentProps, FlowOperation, InsertContentData>;

// @public
export interface InsertContentData {
    at: number;
    insert: FlowContent;
}

// @public
export interface InsertContentProps {
    content: FlowContent;
    position: number;
}

// @public
export abstract class Interaction {
    static readonly baseType: Type<Interaction>;
    static fromJsonValue(value: JsonValue): Interaction;
    toJsonValue(): JsonValue;
}

// @public @sealed
export class LineBreak extends LineBreakBase implements LineBreakProps {
    constructor(props?: LineBreakProps);
    static readonly classType: Type<LineBreak>;
    static fromData(data: LineBreakData): LineBreak;
    readonly size = 1;
}

// @public
export const LineBreakBase: RecordConstructor<LineBreakProps, InlineNode, LineBreakData>;

// @public
export interface LineBreakData {
    break: "line";
    style?: TextStyle;
}

// @public
export interface LineBreakProps {
    style: TextStyle;
}

// @public
export const LIST_MARKER_KINDS: readonly ["ordered", "decimal", "lower-alpha", "upper-alpha", "lower-roman", "upper-roman", "unordered", "disc", "circle", "square", "dash"];

// @public
export type ListMarkerKind = OrderedListMarkerKind | UnorderedListMarkerKind;

// @public
export const ListMarkerKindType: Type<ListMarkerKind>;

// @public
export abstract class NestedFlowOperation extends FlowOperation {
    // @override
    afterInsertion(range: FlowRange): FlowOperation | null;
    // @override
    afterRemoval(range: FlowRange): FlowOperation | null;
    applyToContent(content: FlowContent, theme?: FlowTheme): FlowContent;
    // @override
    applyToSelection(selection: FlowSelection, mine: boolean): FlowSelection | null;
    protected abstract createReplacementNode(content: FlowContent, before: FlowNode): FlowNode;
    protected getInnerContent(outer: FlowContent): FlowContent;
    protected abstract getInnerContentFromNode(node: FlowNode): FlowContent;
    protected getTargetNode(outer: FlowContent): FlowNode;
    abstract inner: FlowOperation;
    invert(content: FlowContent): FlowOperation | null;
    abstract position: number;
    abstract set(key: "position", value: number): this;
    abstract set(key: "inner", value: FlowOperation): this;
    transform(other: FlowOperation): FlowOperation | null;
}

// @public
export abstract class NestedFlowSelection extends FlowSelection {
    // @override
    afterInsertion(range: FlowRange): FlowSelection | null;
    // @override
    afterRemoval(range: FlowRange, mine: boolean): FlowSelection | null;
    // @override
    formatBox(style: BoxStyle, options?: TargetOptions): FlowOperation | null;
    // @override
    formatList(content: FlowContent, kind: "ordered" | "unordered" | null): FlowOperation | null;
    // @override
    formatParagraph(style: ParagraphStyle, options?: TargetOptions): FlowOperation | null;
    // @override
    formatText(style: TextStyle, options?: TargetOptions): FlowOperation | null;
    protected getInnerContent(outer: FlowContent): FlowContent;
    protected abstract getInnerContentFromNode(node: FlowNode): FlowContent;
    protected abstract getInnerSelection(): FlowSelection;
    protected abstract getOuterOperation(inner: FlowOperation): FlowOperation;
    protected getSelectedNode(outer: FlowContent): FlowNode;
    // @override
    getUniformParagraphStyle(content: FlowContent, theme?: FlowTheme, diff?: Set<keyof ParagraphStyleProps>): ParagraphStyle;
    // @override
    getUniformTextStyle(content: FlowContent, theme?: FlowTheme, diff?: Set<keyof TextStyleProps>): TextStyle;
    // @override
    incrementListLevel(content: FlowContent, delta?: number): FlowOperation | null;
    // @override
    insert(content: FlowContent, options?: TargetOptions): FlowOperation | null;
    // @override
    get isCollapsed(): boolean;
    abstract position: number;
    // @override
    remove(options?: RemoveFlowSelectionOptions): FlowOperation | null;
    abstract set(key: "position", value: number): this;
    protected abstract setInnerSelection(value: FlowSelection): NestedFlowSelection;
    // @override
    transformRanges(transform: (range: FlowRange, options?: TargetOptions) => FlowRange | null, options?: TargetOptions): FlowSelection | null;
    // @override
    unformatBox(style: BoxStyle): FlowOperation | null;
    // @override
    unformatParagraph(style: ParagraphStyle): FlowOperation | null;
    // @override
    unformatText(style: TextStyle): FlowOperation | null;
    // @internal
    updateInner(callback: (inner: FlowSelection) => FlowSelection | null): FlowSelection | null;
}

// @public @sealed
export class OpenUrl extends OpenUrlBase {
    static readonly classType: Type<OpenUrl>;
    static fromData(data: string): OpenUrl;
}

// @public
export const OpenUrlBase: RecordConstructor<OpenUrlProps, Interaction, string>;

// @public
export interface OpenUrlProps {
    url: string;
}

// @public
export const ORDERED_LIST_MARKER_KINDS: readonly ["ordered", "decimal", "lower-alpha", "upper-alpha", "lower-roman", "upper-roman"];

// @public
export type OrderedListMarkerKind = (typeof ORDERED_LIST_MARKER_KINDS)[number];

// @public
export const OrderedListMarkerKindType: Type<ListMarkerKind>;

// @public
export const PARAGRAPH_VARIANTS: readonly ["normal", "h1", "h2", "h3", "h4", "h5", "h6", "title", "subtitle", "preamble", "code"];

// @public @sealed
export class ParagraphBreak extends ParagraphBreakBase implements ParagraphBreakProps {
    constructor(props?: ParagraphBreakProps);
    static readonly classType: Type<ParagraphBreak>;
    formatBox(): this;
    formatParagraph(style: ParagraphStyle): this;
    formatText(): this;
    static fromData(data: ParagraphBreakData): ParagraphBreak;
    // @override
    getUniformParagraphStyle(theme?: ParagraphTheme): ParagraphStyle | null;
    // @override
    getUniformTextStyle(theme?: ParagraphTheme): TextStyle;
    readonly size = 1;
    unformatAmbient(theme: ParagraphTheme): this;
    unformatBox(): this;
    unformatParagraph(style: ParagraphStyle): this;
    unformatText(): this;
}

// @public
export const ParagraphBreakBase: RecordConstructor<ParagraphBreakProps, FlowNode, ParagraphBreakData>;

// @public
export interface ParagraphBreakData {
    break: "para";
    style?: ParagraphStyle;
}

// @public
export interface ParagraphBreakProps {
    style: ParagraphStyle;
}

// @public @sealed
export class ParagraphStyle extends ParagraphStyleBase implements Readonly<ParagraphStyleProps> {
    constructor(props?: ParagraphStyleProps);
    static readonly classType: Type<RecordObject<Partial<{
    alignment: "start" | "center" | "end" | "justify";
    direction: "ltr" | "rtl";
    variant: "normal" | "h1" | "h2" | "h3" | "h4" | "h5" | "h6" | "title" | "subtitle" | "preamble" | "code";
    lineSpacing: number;
    spaceAbove: number;
    spaceBelow: number;
    listLevel: number;
    listMarker: ListMarkerKind;
    hideListMarker: boolean;
    listCounter: number | "auto" | "reset" | "resume";
    listCounterPrefix: string;
    listCounterSuffix: string;
    }>, Partial<{
    alignment: "start" | "center" | "end" | "justify";
    direction: "ltr" | "rtl";
    variant: "normal" | "h1" | "h2" | "h3" | "h4" | "h5" | "h6" | "title" | "subtitle" | "preamble" | "code";
    lineSpacing: number;
    spaceAbove: number;
    spaceBelow: number;
    listLevel: number;
    listMarker: ListMarkerKind;
    hideListMarker: boolean;
    listCounter: number | "auto" | "reset" | "resume";
    listCounterPrefix: string;
    listCounterSuffix: string;
    }>> & Equatable & Readonly<Partial<{
        alignment: "start" | "center" | "end" | "justify";
        direction: "ltr" | "rtl";
        variant: "normal" | "h1" | "h2" | "h3" | "h4" | "h5" | "h6" | "title" | "subtitle" | "preamble" | "code";
        lineSpacing: number;
        spaceAbove: number;
        spaceBelow: number;
        listLevel: number;
        listMarker: ListMarkerKind;
        hideListMarker: boolean;
        listCounter: number | "auto" | "reset" | "resume";
        listCounterPrefix: string;
        listCounterSuffix: string;
    }>> & ParagraphStyle>;
    static get empty(): ParagraphStyle;
    get isEmpty(): boolean;
}

// @public
export const ParagraphStyleBase: RecordConstructor<Partial<{
alignment: "start" | "center" | "end" | "justify";
direction: "ltr" | "rtl";
variant: "normal" | "h1" | "h2" | "h3" | "h4" | "h5" | "h6" | "title" | "subtitle" | "preamble" | "code";
lineSpacing: number;
spaceAbove: number;
spaceBelow: number;
listLevel: number;
listMarker: ListMarkerKind;
hideListMarker: boolean;
listCounter: number | "auto" | "reset" | "resume";
listCounterPrefix: string;
listCounterSuffix: string;
}>, Object, Partial<{
alignment: "start" | "center" | "end" | "justify";
direction: "ltr" | "rtl";
variant: "normal" | "h1" | "h2" | "h3" | "h4" | "h5" | "h6" | "title" | "subtitle" | "preamble" | "code";
lineSpacing: number;
spaceAbove: number;
spaceBelow: number;
listLevel: number;
listMarker: ListMarkerKind;
hideListMarker: boolean;
listCounter: number | "auto" | "reset" | "resume";
listCounterPrefix: string;
listCounterSuffix: string;
}>>;

// @public
export interface ParagraphStyleProps {
    alignment?: "start" | "center" | "end" | "justify";
    direction?: "ltr" | "rtl";
    hideListMarker?: boolean;
    lineSpacing?: number;
    listCounter?: number | "auto" | "reset" | "resume";
    listCounterPrefix?: string;
    listCounterSuffix?: string;
    listLevel?: number;
    listMarker?: ListMarkerKind;
    spaceAbove?: number;
    spaceBelow?: number;
    variant?: ParagraphVariant;
}

// @public
export abstract class ParagraphTheme {
    abstract getAmbientParagraphStyle(): ParagraphStyle;
    abstract getAmbientTextStyle(): TextStyle;
    abstract getFlowTheme(): FlowTheme;
    abstract getLinkStyle(): TextStyle;
    abstract getNextVariant(): ParagraphVariant;
}

// @public
export type ParagraphVariant = (typeof PARAGRAPH_VARIANTS)[number];

// @public
export const ParagraphVariantType: Type<ParagraphVariant>;

// @public
export interface RemoveFlowSelectionOptions extends TargetOptions {
    whenCollapsed?: "removeBackward" | "removeForward" | "noop";
}

// @public @sealed
export class RemoveRange extends RemoveRangeBase implements Readonly<RemoveRangeProps> {
    afterInsertion(other: FlowRange): FlowOperation | null;
    afterRemoval(other: FlowRange): FlowOperation | null;
    // @override
    applyToContent(content: FlowContent): FlowContent;
    // @override
    applyToSelection(selection: FlowSelection, mine: boolean): FlowSelection | null;
    static readonly classType: Type<RemoveRange>;
    static fromData(data: RemoveRangeData): RemoveRange;
    // @override
    invert(content: FlowContent): InsertContent;
    mergeNext(next: FlowOperation): FlowOperation | null;
    // @override
    transform(other: FlowOperation): FlowOperation | null;
}

// @public
export const RemoveRangeBase: RecordConstructor<RemoveRangeProps, FlowOperation, RemoveRangeData>;

// @public
export interface RemoveRangeData {
    remove: FlowRange;
}

// @public
export interface RemoveRangeProps {
    range: FlowRange;
}

// @public @sealed
export class RunScript extends RunScriptBase {
    static readonly classType: Type<RecordObject<RunScriptProps, RunScriptProps> & Equatable & Readonly<RunScriptProps> & RunScript>;
}

// @public
export const RunScriptBase: RecordConstructor<RunScriptProps, Interaction, RunScriptProps>;

// @public
export interface RunScriptProps {
    script: string;
}

// @public @sealed
export class SetDynamicTextExpression extends SetDynamicTextExpressionBase implements SetDynamicTextExpressionProps {
    afterInsertion(range: FlowRange): FlowOperation | null;
    afterRemoval(range: FlowRange): FlowOperation | null;
    // @override
    applyToContent(content: FlowContent): FlowContent;
    // @override
    applyToSelection(selection: FlowSelection): FlowSelection;
    static readonly classType: Type<SetDynamicTextExpression>;
    static fromData(data: SetDynamicTextExpressionData): SetDynamicTextExpression;
    // @override
    invert(content: FlowContent): FlowOperation | null;
    mergeNext(next: FlowOperation): FlowOperation | null;
    // @override
    transform(other: FlowOperation): FlowOperation | null;
}

// @public
export const SetDynamicTextExpressionBase: RecordConstructor<SetDynamicTextExpressionProps, FlowOperation, SetDynamicTextExpressionData>;

// @public
export interface SetDynamicTextExpressionData {
    at: number;
    set: "dynamic_text_expression";
    value: string;
}

// @public
export interface SetDynamicTextExpressionProps {
    expression: string;
    position: number;
}

// @public
export interface TargetOptions {
    target?: FlowContent;
    theme?: FlowTheme;
}

// @public @sealed
export class TextRun extends TextRunBase implements Readonly<TextRunProps> {
    constructor(props?: TextRunProps);
    after(position: number): TextRun;
    append(value: string): TextRun;
    before(position: number): TextRun;
    static readonly classType: Type<TextRun>;
    static fromData(data: TextRunData): TextRun;
    // @internal
    static merge(first: TextRun, second: TextRun): TextRun;
    static normalizeText(value: unknown): string;
    // @internal
    static shouldMerge(first: TextRun, second: TextRun): boolean;
    readonly size: number;
    split(position: number): [TextRun, TextRun];
}

// @public
export const TextRunBase: RecordConstructor<TextRunProps, InlineNode, TextRunData>;

// @public
export type TextRunData = string | (Pick<TextRunProps, "text"> & Partial<Omit<TextRunProps, "text">>);

// @public
export interface TextRunProps {
    style: TextStyle;
    text: string;
}

// @public @sealed
export class TextStyle extends TextStyleBase implements Readonly<TextStyleProps> {
    constructor(props?: TextStyleProps);
    static readonly classType: Type<RecordObject<Partial<{
    bold: boolean;
    italic: boolean;
    underline: boolean;
    strike: boolean;
    baseline: "normal" | "sub" | "super";
    fontFamily: "body" | "heading" | "monospace";
    fontSize: number;
    link: Interaction | null;
    color: "default" | "subtle" | "primary" | "secondary" | "information" | "success" | "warning" | "error";
    }>, Partial<{
    bold: boolean;
    italic: boolean;
    underline: boolean;
    strike: boolean;
    baseline: "normal" | "sub" | "super";
    fontFamily: "body" | "heading" | "monospace";
    fontSize: number;
    link: Interaction | null;
    color: "default" | "subtle" | "primary" | "secondary" | "information" | "success" | "warning" | "error";
    }>> & Equatable & Readonly<Partial<{
    bold: boolean;
    italic: boolean;
    underline: boolean;
    strike: boolean;
    baseline: "normal" | "sub" | "super";
    fontFamily: "body" | "heading" | "monospace";
    fontSize: number;
    link: Interaction | null;
    color: "default" | "subtle" | "primary" | "secondary" | "information" | "success" | "warning" | "error";
    }>> & TextStyle>;
    static get empty(): TextStyle;
    get isEmpty(): boolean;
}

// @public
export const TextStyleBase: RecordConstructor<Partial<{
bold: boolean;
italic: boolean;
underline: boolean;
strike: boolean;
baseline: "normal" | "sub" | "super";
fontFamily: "body" | "heading" | "monospace";
fontSize: number;
link: Interaction | null;
color: "default" | "subtle" | "primary" | "secondary" | "information" | "success" | "warning" | "error";
}>, Object, Partial<{
bold: boolean;
italic: boolean;
underline: boolean;
strike: boolean;
baseline: "normal" | "sub" | "super";
fontFamily: "body" | "heading" | "monospace";
fontSize: number;
link: Interaction | null;
color: "default" | "subtle" | "primary" | "secondary" | "information" | "success" | "warning" | "error";
}>>;

// @public
export interface TextStyleProps {
    baseline?: "normal" | "sub" | "super";
    bold?: boolean;
    color?: FlowColor;
    fontFamily?: "body" | "heading" | "monospace";
    fontSize?: number;
    italic?: boolean;
    link?: Interaction | null;
    strike?: boolean;
    underline?: boolean;
}

// @public @sealed
export class UnformatBox extends UnformatBoxBase implements Readonly<UnformatBoxProps> {
    afterInsertion(other: FlowRange): FlowOperation | null;
    afterRemoval(other: FlowRange): FlowOperation | null;
    // @override
    applyToContent(content: FlowContent): FlowContent;
    // @override
    applyToSelection(selection: FlowSelection): FlowSelection;
    static readonly classType: Type<UnformatBox>;
    static fromData(data: UnformatBoxData): UnformatBox;
    // @override
    invert(content: FlowContent): FlowOperation | null;
    mergeNext(next: FlowOperation): FlowOperation | null;
    // @override
    transform(other: FlowOperation): FlowOperation | null;
}

// @public
export const UnformatBoxBase: RecordConstructor<UnformatBoxProps, FlowOperation, UnformatBoxData>;

// @public
export interface UnformatBoxData extends UnformatBoxProps {
    unformat: "box";
}

// @public
export interface UnformatBoxProps {
    range: FlowRange;
    style: BoxStyle;
}

// @public @sealed
export class UnformatParagraph extends UnformatParagraphBase implements Readonly<UnformatParagraphProps> {
    afterInsertion(other: FlowRange): FlowOperation | null;
    afterRemoval(other: FlowRange): FlowOperation | null;
    // @override
    applyToContent(content: FlowContent): FlowContent;
    // @override
    applyToSelection(selection: FlowSelection): FlowSelection;
    static readonly classType: Type<UnformatParagraph>;
    static fromData(data: UnformatParagraphData): UnformatParagraph;
    // @override
    invert(content: FlowContent): FlowOperation | null;
    mergeNext(next: FlowOperation): FlowOperation | null;
    // @override
    transform(other: FlowOperation): FlowOperation | null;
}

// @public
export const UnformatParagraphBase: RecordConstructor<UnformatParagraphProps, FlowOperation, UnformatParagraphData>;

// @public
export interface UnformatParagraphData extends UnformatParagraphProps {
    unformat: "para";
}

// @public
export interface UnformatParagraphProps {
    range: FlowRange;
    style: ParagraphStyle;
}

// @public @sealed
export class UnformatText extends UnformatTextBase implements Readonly<UnformatTextProps> {
    afterInsertion(other: FlowRange): FlowOperation | null;
    afterRemoval(other: FlowRange): FlowOperation | null;
    // @override
    applyToContent(content: FlowContent): FlowContent;
    // @override
    applyToSelection(selection: FlowSelection): FlowSelection;
    static readonly classType: Type<UnformatText>;
    static fromData(data: UnformatTextData): UnformatText;
    // @override
    invert(content: FlowContent): FlowOperation | null;
    mergeNext(next: FlowOperation): FlowOperation | null;
    // @override
    transform(other: FlowOperation): FlowOperation | null;
}

// @public
export const UnformatTextBase: RecordConstructor<UnformatTextProps, FlowOperation, UnformatTextData>;

// @public
export interface UnformatTextData extends UnformatTextProps {
    unformat: "text";
}

// @public
export interface UnformatTextProps {
    range: FlowRange;
    style: TextStyle;
}

// @public
export const UNORDERED_LIST_MARKER_KINDS: readonly ["unordered", "disc", "circle", "square", "dash"];

// @public
export type UnorderedListMarkerKind = (typeof UNORDERED_LIST_MARKER_KINDS)[number];

// @public
export const UnorderedListMarkerKindType: Type<ListMarkerKind>;

```
