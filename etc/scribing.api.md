## API Report File for "scribing"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Equatable } from 'paratype';
import { JsonValue } from 'paratype';
import { RecordConstructor } from 'paratype';
import { RecordObject } from 'paratype';
import { Type } from 'paratype';

// Warning: (ae-forgotten-export) The symbol "BASE" needs to be exported by the entry point index.d.ts
//
// @public @sealed
export class FlowBatch extends BASE_3 implements Readonly<FlowBatchProps> {
    constructor(props?: FlowBatchProps);
    // (undocumented)
    afterInsertion(other: FlowRange): FlowOperation | null;
    // (undocumented)
    afterRemoval(other: FlowRange): FlowOperation | null;
    applyTo(container: FlowContent): FlowContent;
    // (undocumented)
    static readonly classType: Type<FlowBatch>;
    static fromData(data: FlowBatchData): FlowBatch;
    invert(state: FlowContent): FlowOperation | null;
    transform(other: FlowOperation): FlowOperation | null;
}

// @public
export type FlowBatchData = readonly FlowOperation[];

// @public
export interface FlowBatchProps {
    operations: readonly FlowOperation[];
}

// Warning: (ae-forgotten-export) The symbol "BASE" needs to be exported by the entry point index.d.ts
//
// @public @sealed
export class FlowContent extends BASE implements Readonly<FlowContentProps> {
    constructor(props?: FlowContentProps);
    append(...nodes: readonly FlowNode[]): FlowContent;
    // (undocumented)
    static readonly classType: Type<FlowContent>;
    copy(range: FlowRange): FlowContent;
    formatParagraph(range: FlowRange, style: ParagraphStyle): FlowContent;
    formatText(range: FlowRange, style: TextStyle): FlowContent;
    // (undocumented)
    static fromData(data: FlowContentData): FlowContent;
    insert(position: number, ...nodes: readonly FlowNode[]): FlowContent;
    peek(position?: number): FlowCursor;
    remove(range: FlowRange): FlowContent;
    get size(): number;
    // (undocumented)
    toJsonValue(): JsonValue;
    unformatParagraph(range: FlowRange, style: ParagraphStyle): FlowContent;
    unformatText(range: FlowRange, style: TextStyle): FlowContent;
}

// @public
export type FlowContentData = readonly FlowNode[];

// @public
export interface FlowContentProps {
    nodes: readonly FlowNode[];
}

// @public
export class FlowCursor {
    // @internal
    constructor(content: FlowContent);
    // @internal
    constructor(content: FlowContent, symbol: symbol, index: number, offset: number, position: number);
    get after(): Iterable<FlowNode>;
    get before(): Iterable<FlowNode>;
    get index(): number;
    move(distance: number): FlowCursor;
    // (undocumented)
    moveToStartOfNextNode(): FlowCursor | null;
    // (undocumented)
    moveToStartOfNode(): FlowCursor;
    // (undocumented)
    moveToStartOfPreviousNode(): FlowCursor | null;
    get node(): FlowNode | null;
    get offset(): number;
    get position(): number;
    range(distance: number): Iterable<FlowNode>;
}

// @public
export abstract class FlowNode {
    abstract formatParagraph(style: ParagraphStyle): FlowNode;
    abstract formatText(style: TextStyle): FlowNode;
    // (undocumented)
    static fromJsonValue(value: JsonValue): FlowNode;
    // @internal (undocumented)
    abstract getParagraphStyle(): ParagraphStyle | null;
    // @internal (undocumented)
    abstract getTextStyle(): TextStyle | null;
    abstract readonly size: number;
    // (undocumented)
    abstract toData(): unknown;
    // (undocumented)
    toJsonValue(): JsonValue;
    abstract unformatParagraph(style: ParagraphStyle): FlowNode;
    abstract unformatText(style: TextStyle): FlowNode;
}

// @public
export abstract class FlowOperation {
    // @internal (undocumented)
    abstract afterInsertion(other: FlowRange): FlowOperation | null;
    // @internal (undocumented)
    abstract afterRemoval(other: FlowRange): FlowOperation | null;
    abstract applyTo(state: FlowContent): FlowContent;
    // @internal (undocumented)
    static batch(operations: FlowOperation[]): FlowOperation | null;
    // (undocumented)
    static fromJsonValue(value: JsonValue): FlowOperation;
    abstract invert(state: FlowContent): FlowOperation | null;
    // (undocumented)
    abstract toData(): unknown;
    // (undocumented)
    toJsonValue(): JsonValue;
    abstract transform(other: FlowOperation): FlowOperation | null;
}

// Warning: (ae-forgotten-export) The symbol "BASE" needs to be exported by the entry point index.d.ts
//
// @public
export class FlowRange extends BASE_2 implements Readonly<FlowRangeProps> {
    static at(position: number, distance?: number): FlowRange;
    static readonly classType: Type<FlowRange>;
    contains(position: number): boolean;
    // (undocumented)
    deflate(distance: number): FlowRange;
    get distance(): number;
    get first(): number;
    static fromData(data: FlowRangeTuple): FlowRange;
    // (undocumented)
    inflate(distance: number): FlowRange;
    // (undocumented)
    intersect(other: FlowRange): FlowRange;
    get isBackward(): boolean;
    get isCollapsed(): boolean;
    get last(): number;
    // (undocumented)
    reverse(): FlowRange;
    // (undocumented)
    set(key: "first" | "last" | keyof FlowRangeProps, value: number): this;
    get size(): number;
    // (undocumented)
    toString(): string;
    // (undocumented)
    translate(distance: number): FlowRange;
}

// @public
export interface FlowRangeProps {
    anchor: number;
    focus: number;
}

// @public
export type FlowRangeTuple = [number, number];

// Warning: (ae-forgotten-export) The symbol "BASE" needs to be exported by the entry point index.d.ts
//
// @public @sealed
export class FormatParagraph extends BASE_4 implements Readonly<FormatParagraphProps> {
    // (undocumented)
    afterInsertion(other: FlowRange): FlowOperation | null;
    // (undocumented)
    afterRemoval(other: FlowRange): FlowOperation | null;
    // @override
    applyTo(container: FlowContent): FlowContent;
    // (undocumented)
    static readonly classType: Type<FormatParagraph>;
    // (undocumented)
    static fromData(data: FormatParagraphData): FormatParagraph;
    // @override
    invert(state: FlowContent): FlowOperation | null;
    // @override
    transform(other: FlowOperation): FlowOperation | null;
}

// @public
export interface FormatParagraphData {
    // (undocumented)
    format: "para";
    // (undocumented)
    range: FlowRange;
    // (undocumented)
    style: ParagraphStyle;
}

// @public
export interface FormatParagraphProps {
    // (undocumented)
    range: FlowRange;
    // (undocumented)
    style: ParagraphStyle;
}

// Warning: (ae-forgotten-export) The symbol "BASE" needs to be exported by the entry point index.d.ts
//
// @public @sealed
export class FormatText extends BASE_5 implements Readonly<FormatTextProps> {
    // (undocumented)
    afterInsertion(other: FlowRange): FlowOperation | null;
    // (undocumented)
    afterRemoval(other: FlowRange): FlowOperation | null;
    // @override
    applyTo(container: FlowContent): FlowContent;
    // (undocumented)
    static readonly classType: Type<FormatText>;
    // (undocumented)
    static fromData(data: FormatTextData): FormatText;
    // @override
    invert(state: FlowContent): FlowOperation | null;
    // @override
    transform(other: FlowOperation): FlowOperation | null;
}

// @public
export interface FormatTextData {
    // (undocumented)
    format: "text";
    // (undocumented)
    range: FlowRange;
    // (undocumented)
    style: TextStyle;
}

// @public
export interface FormatTextProps {
    // (undocumented)
    range: FlowRange;
    // (undocumented)
    style: TextStyle;
}

// @public
export abstract class InlineNode extends FlowNode {
    // (undocumented)
    formatParagraph(): this;
    // (undocumented)
    formatText(style: TextStyle): this;
    // (undocumented)
    getParagraphStyle(): null;
    // (undocumented)
    getTextStyle(): TextStyle;
    // (undocumented)
    abstract set(key: "style", value: TextStyle): this;
    // (undocumented)
    abstract readonly style: TextStyle;
    // (undocumented)
    unformatParagraph(): this;
    // (undocumented)
    unformatText(style: TextStyle): this;
}

// Warning: (ae-forgotten-export) The symbol "BASE" needs to be exported by the entry point index.d.ts
//
// @public @sealed
export class InsertContent extends BASE_6 implements InsertContentProps {
    // (undocumented)
    afterInsertion(other: FlowRange): FlowOperation | null;
    // (undocumented)
    afterRemoval(other: FlowRange): FlowOperation | null;
    applyTo(container: FlowContent): FlowContent;
    // (undocumented)
    static readonly classType: Type<InsertContent>;
    // (undocumented)
    static fromData(data: InsertContentData): InsertContent;
    invert(): FlowOperation | null;
    // (undocumented)
    toData(): InsertContentData;
    transform(other: FlowOperation): FlowOperation | null;
    // @internal (undocumented)
    translate(distance: number): InsertContent;
}

// @public
export interface InsertContentData {
    // (undocumented)
    at: number;
    // (undocumented)
    insert: FlowContent;
}

// @public
export interface InsertContentProps {
    // (undocumented)
    content: FlowContent;
    // (undocumented)
    position: number;
}

// Warning: (ae-forgotten-export) The symbol "BASE" needs to be exported by the entry point index.d.ts
//
// @public @sealed
export class LineBreak extends BASE_10 implements LineBreakProps {
    constructor(props?: LineBreakProps);
    // (undocumented)
    static readonly classType: Type<LineBreak>;
    // (undocumented)
    static fromData(data: LineBreakData): LineBreak;
    // (undocumented)
    readonly size = 1;
}

// @public
export interface LineBreakData {
    // (undocumented)
    break: "line";
    // (undocumented)
    style?: TextStyle;
}

// @public
export interface LineBreakProps {
    style: TextStyle;
}

// Warning: (ae-forgotten-export) The symbol "BASE" needs to be exported by the entry point index.d.ts
//
// @public @sealed
export class ParagraphBreak extends BASE_11 implements ParagraphBreakProps {
    constructor(props?: ParagraphBreakProps);
    // (undocumented)
    static readonly classType: Type<ParagraphBreak>;
    // (undocumented)
    formatParagraph(style: ParagraphStyle): this;
    // (undocumented)
    formatText(): this;
    // (undocumented)
    static fromData(data: ParagraphBreakData): ParagraphBreak;
    // (undocumented)
    getParagraphStyle(): ParagraphStyle;
    // (undocumented)
    getTextStyle(): null;
    // (undocumented)
    readonly size = 1;
    // (undocumented)
    unformatParagraph(style: ParagraphStyle): this;
    // (undocumented)
    unformatText(): this;
}

// @public
export interface ParagraphBreakData {
    // (undocumented)
    break: "para";
    // (undocumented)
    style?: ParagraphStyle;
}

// @public
export interface ParagraphBreakProps {
    style: ParagraphStyle;
}

// Warning: (ae-forgotten-export) The symbol "ParagraphStyle_base" needs to be exported by the entry point index.d.ts
//
// @public @sealed
export class ParagraphStyle extends ParagraphStyle_base implements Readonly<ParagraphStyleProps> {
    constructor(props?: ParagraphStyleProps);
    // (undocumented)
    static readonly classType: Type<RecordObject<Partial<{
    alignment: "start" | "center" | "end" | "justified";
    direction: "ltr" | "rtl";
    type: "normal" | "title" | "subtitle" | "h1" | "h2" | "h3" | "h4" | "h5" | "h6";
    line_spacing: number;
    }>, Partial<{
    alignment: "start" | "center" | "end" | "justified";
    direction: "ltr" | "rtl";
    type: "normal" | "title" | "subtitle" | "h1" | "h2" | "h3" | "h4" | "h5" | "h6";
    line_spacing: number;
    }>> & Equatable & Readonly<Partial<{
    alignment: "start" | "center" | "end" | "justified";
    direction: "ltr" | "rtl";
    type: "normal" | "title" | "subtitle" | "h1" | "h2" | "h3" | "h4" | "h5" | "h6";
    line_spacing: number;
    }>> & ParagraphStyle>;
    // (undocumented)
    static get empty(): ParagraphStyle;
    // (undocumented)
    get isEmpty(): boolean;
}

// @public
export interface ParagraphStyleProps {
    alignment?: "start" | "center" | "end" | "justified";
    direction?: "ltr" | "rtl";
    line_spacing?: number;
    type?: "normal" | "title" | "subtitle" | "h1" | "h2" | "h3" | "h4" | "h5" | "h6";
}

// Warning: (ae-forgotten-export) The symbol "BASE" needs to be exported by the entry point index.d.ts
//
// @public @sealed
export class RemoveRange extends BASE_7 implements Readonly<RemoveRangeProps> {
    // (undocumented)
    afterInsertion(other: FlowRange): FlowOperation | null;
    // (undocumented)
    afterRemoval(other: FlowRange): FlowOperation | null;
    // @override
    applyTo(container: FlowContent): FlowContent;
    // (undocumented)
    static readonly classType: Type<RemoveRange>;
    // (undocumented)
    static fromData(data: RemoveRangeData): RemoveRange;
    // @override
    invert(state: FlowContent): InsertContent;
    // @override
    transform(other: FlowOperation): FlowOperation | null;
}

// @public
export interface RemoveRangeData {
    // (undocumented)
    remove: FlowRange;
}

// @public
export interface RemoveRangeProps {
    // (undocumented)
    range: FlowRange;
}

// Warning: (ae-forgotten-export) The symbol "BASE" needs to be exported by the entry point index.d.ts
//
// @public @sealed
export class TextRun extends BASE_12 implements Readonly<TextRunProps> {
    constructor(props?: TextRunProps);
    // (undocumented)
    after(position: number): TextRun;
    // (undocumented)
    append(value: string): TextRun;
    // (undocumented)
    before(position: number): TextRun;
    // (undocumented)
    static readonly classType: Type<TextRun>;
    // (undocumented)
    static fromData(data: TextRunData): TextRun;
    // @internal (undocumented)
    static merge(first: TextRun, second: TextRun): TextRun;
    // (undocumented)
    static normalizeText(value: unknown): string;
    // @internal (undocumented)
    static shouldMerge(first: TextRun, second: TextRun): boolean;
    // (undocumented)
    readonly size: number;
    // (undocumented)
    split(position: number): [TextRun, TextRun];
}

// @public
export type TextRunData = string | {
    text: string;
    style?: TextStyle;
};

// @public
export interface TextRunProps {
    // (undocumented)
    style: TextStyle;
    // (undocumented)
    text: string;
}

// Warning: (ae-forgotten-export) The symbol "TextStyle_base" needs to be exported by the entry point index.d.ts
//
// @public @sealed
export class TextStyle extends TextStyle_base implements Readonly<TextStyleProps> {
    constructor(props?: TextStyleProps);
    // (undocumented)
    static readonly classType: Type<RecordObject<Partial<{
    bold: boolean;
    italic: boolean;
    underline: boolean;
    strike: boolean;
    baseline: "normal" | "sub" | "super";
    }>, Partial<{
    bold: boolean;
    italic: boolean;
    underline: boolean;
    strike: boolean;
    baseline: "normal" | "sub" | "super";
    }>> & Equatable & Readonly<Partial<{
    bold: boolean;
    italic: boolean;
    underline: boolean;
    strike: boolean;
    baseline: "normal" | "sub" | "super";
    }>> & TextStyle>;
    // (undocumented)
    static get empty(): TextStyle;
    // (undocumented)
    get isEmpty(): boolean;
}

// @public
export interface TextStyleProps {
    baseline?: "normal" | "sub" | "super";
    bold?: boolean;
    italic?: boolean;
    strike?: boolean;
    underline?: boolean;
}

// Warning: (ae-forgotten-export) The symbol "BASE" needs to be exported by the entry point index.d.ts
//
// @public @sealed
export class UnformatParagraph extends BASE_8 implements Readonly<UnformatParagraphProps> {
    // (undocumented)
    afterInsertion(other: FlowRange): FlowOperation | null;
    // (undocumented)
    afterRemoval(other: FlowRange): FlowOperation | null;
    // @override
    applyTo(container: FlowContent): FlowContent;
    // (undocumented)
    static readonly classType: Type<UnformatParagraph>;
    // (undocumented)
    static fromData(data: UnformatParagraphData): UnformatParagraph;
    // @override
    invert(state: FlowContent): FlowOperation | null;
    // @override
    transform(other: FlowOperation): FlowOperation | null;
}

// @public
export interface UnformatParagraphData {
    // (undocumented)
    range: FlowRange;
    // (undocumented)
    style: ParagraphStyle;
    // (undocumented)
    unformat: "para";
}

// @public
export interface UnformatParagraphProps {
    // (undocumented)
    range: FlowRange;
    // (undocumented)
    style: ParagraphStyle;
}

// Warning: (ae-forgotten-export) The symbol "BASE" needs to be exported by the entry point index.d.ts
//
// @public @sealed
export class UnformatText extends BASE_9 implements Readonly<UnformatTextProps> {
    // (undocumented)
    afterInsertion(other: FlowRange): FlowOperation | null;
    // (undocumented)
    afterRemoval(other: FlowRange): FlowOperation | null;
    // @override
    applyTo(container: FlowContent): FlowContent;
    // (undocumented)
    static readonly classType: Type<UnformatText>;
    // (undocumented)
    static fromData(data: UnformatTextData): UnformatText;
    // @override
    invert(state: FlowContent): FlowOperation | null;
    // @override
    transform(other: FlowOperation): FlowOperation | null;
}

// @public
export interface UnformatTextData {
    // (undocumented)
    range: FlowRange;
    // (undocumented)
    style: TextStyle;
    // (undocumented)
    unformat: "text";
}

// @public
export interface UnformatTextProps {
    // (undocumented)
    range: FlowRange;
    // (undocumented)
    style: TextStyle;
}

```
